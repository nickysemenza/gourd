// Code generated by SQLBoiler 4.8.1 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// UsdaFood is an object representing the database table.
type UsdaFood struct {
	FDCID           int         `boil:"fdc_id" json:"fdc_id" toml:"fdc_id" yaml:"fdc_id"`
	DataType        null.String `boil:"data_type" json:"data_type,omitempty" toml:"data_type" yaml:"data_type,omitempty"`
	Description     null.String `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	FoodCategoryID  null.Int    `boil:"food_category_id" json:"food_category_id,omitempty" toml:"food_category_id" yaml:"food_category_id,omitempty"`
	PublicationDate null.String `boil:"publication_date" json:"publication_date,omitempty" toml:"publication_date" yaml:"publication_date,omitempty"`

	R *usdaFoodR `boil:"rel" json:"rel" toml:"rel" yaml:"rel"`
	L usdaFoodL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UsdaFoodColumns = struct {
	FDCID           string
	DataType        string
	Description     string
	FoodCategoryID  string
	PublicationDate string
}{
	FDCID:           "fdc_id",
	DataType:        "data_type",
	Description:     "description",
	FoodCategoryID:  "food_category_id",
	PublicationDate: "publication_date",
}

var UsdaFoodTableColumns = struct {
	FDCID           string
	DataType        string
	Description     string
	FoodCategoryID  string
	PublicationDate string
}{
	FDCID:           "usda_food.fdc_id",
	DataType:        "usda_food.data_type",
	Description:     "usda_food.description",
	FoodCategoryID:  "usda_food.food_category_id",
	PublicationDate: "usda_food.publication_date",
}

// Generated where

var UsdaFoodWhere = struct {
	FDCID           whereHelperint
	DataType        whereHelpernull_String
	Description     whereHelpernull_String
	FoodCategoryID  whereHelpernull_Int
	PublicationDate whereHelpernull_String
}{
	FDCID:           whereHelperint{field: "\"usda_food\".\"fdc_id\""},
	DataType:        whereHelpernull_String{field: "\"usda_food\".\"data_type\""},
	Description:     whereHelpernull_String{field: "\"usda_food\".\"description\""},
	FoodCategoryID:  whereHelpernull_Int{field: "\"usda_food\".\"food_category_id\""},
	PublicationDate: whereHelpernull_String{field: "\"usda_food\".\"publication_date\""},
}

// UsdaFoodRels is where relationship names are stored.
var UsdaFoodRels = struct {
	FDCUsdaBrandedFood                   string
	FDCUsdaFoundationFood                string
	FDCUsdaMarketAcquisition             string
	FDCUsdaSampleFood                    string
	FDCUsdaSRLegacyFood                  string
	FDCUsdaSubSampleFood                 string
	FDCUsdaSurveyFNDDSFood               string
	FDCIDOfSampleFoodUsdaFoods           string
	FDCIDOfAcquisitionFoodUsdaFoods      string
	FDCUsdaFoodAttributes                string
	FDCUsdaFoodComponents                string
	FDCUsdaFoodNutrientConversionFactors string
	FDCUsdaFoodPortions                  string
	FDCUsdaInputFoods                    string
	FDCIDOfInputFoodUsdaInputFoods       string
	FDCIDOfSampleFoodUsdaSubSampleFoods  string
}{
	FDCUsdaBrandedFood:                   "FDCUsdaBrandedFood",
	FDCUsdaFoundationFood:                "FDCUsdaFoundationFood",
	FDCUsdaMarketAcquisition:             "FDCUsdaMarketAcquisition",
	FDCUsdaSampleFood:                    "FDCUsdaSampleFood",
	FDCUsdaSRLegacyFood:                  "FDCUsdaSRLegacyFood",
	FDCUsdaSubSampleFood:                 "FDCUsdaSubSampleFood",
	FDCUsdaSurveyFNDDSFood:               "FDCUsdaSurveyFNDDSFood",
	FDCIDOfSampleFoodUsdaFoods:           "FDCIDOfSampleFoodUsdaFoods",
	FDCIDOfAcquisitionFoodUsdaFoods:      "FDCIDOfAcquisitionFoodUsdaFoods",
	FDCUsdaFoodAttributes:                "FDCUsdaFoodAttributes",
	FDCUsdaFoodComponents:                "FDCUsdaFoodComponents",
	FDCUsdaFoodNutrientConversionFactors: "FDCUsdaFoodNutrientConversionFactors",
	FDCUsdaFoodPortions:                  "FDCUsdaFoodPortions",
	FDCUsdaInputFoods:                    "FDCUsdaInputFoods",
	FDCIDOfInputFoodUsdaInputFoods:       "FDCIDOfInputFoodUsdaInputFoods",
	FDCIDOfSampleFoodUsdaSubSampleFoods:  "FDCIDOfSampleFoodUsdaSubSampleFoods",
}

// usdaFoodR is where relationships are stored.
type usdaFoodR struct {
	FDCUsdaBrandedFood                   *UsdaBrandedFood                      `boil:"FDCUsdaBrandedFood" json:"FDCUsdaBrandedFood" toml:"FDCUsdaBrandedFood" yaml:"FDCUsdaBrandedFood"`
	FDCUsdaFoundationFood                *UsdaFoundationFood                   `boil:"FDCUsdaFoundationFood" json:"FDCUsdaFoundationFood" toml:"FDCUsdaFoundationFood" yaml:"FDCUsdaFoundationFood"`
	FDCUsdaMarketAcquisition             *UsdaMarketAcquisition                `boil:"FDCUsdaMarketAcquisition" json:"FDCUsdaMarketAcquisition" toml:"FDCUsdaMarketAcquisition" yaml:"FDCUsdaMarketAcquisition"`
	FDCUsdaSampleFood                    *UsdaSampleFood                       `boil:"FDCUsdaSampleFood" json:"FDCUsdaSampleFood" toml:"FDCUsdaSampleFood" yaml:"FDCUsdaSampleFood"`
	FDCUsdaSRLegacyFood                  *UsdaSRLegacyFood                     `boil:"FDCUsdaSRLegacyFood" json:"FDCUsdaSRLegacyFood" toml:"FDCUsdaSRLegacyFood" yaml:"FDCUsdaSRLegacyFood"`
	FDCUsdaSubSampleFood                 *UsdaSubSampleFood                    `boil:"FDCUsdaSubSampleFood" json:"FDCUsdaSubSampleFood" toml:"FDCUsdaSubSampleFood" yaml:"FDCUsdaSubSampleFood"`
	FDCUsdaSurveyFNDDSFood               *UsdaSurveyFNDDSFood                  `boil:"FDCUsdaSurveyFNDDSFood" json:"FDCUsdaSurveyFNDDSFood" toml:"FDCUsdaSurveyFNDDSFood" yaml:"FDCUsdaSurveyFNDDSFood"`
	FDCIDOfSampleFoodUsdaFoods           UsdaFoodSlice                         `boil:"FDCIDOfSampleFoodUsdaFoods" json:"FDCIDOfSampleFoodUsdaFoods" toml:"FDCIDOfSampleFoodUsdaFoods" yaml:"FDCIDOfSampleFoodUsdaFoods"`
	FDCIDOfAcquisitionFoodUsdaFoods      UsdaFoodSlice                         `boil:"FDCIDOfAcquisitionFoodUsdaFoods" json:"FDCIDOfAcquisitionFoodUsdaFoods" toml:"FDCIDOfAcquisitionFoodUsdaFoods" yaml:"FDCIDOfAcquisitionFoodUsdaFoods"`
	FDCUsdaFoodAttributes                UsdaFoodAttributeSlice                `boil:"FDCUsdaFoodAttributes" json:"FDCUsdaFoodAttributes" toml:"FDCUsdaFoodAttributes" yaml:"FDCUsdaFoodAttributes"`
	FDCUsdaFoodComponents                UsdaFoodComponentSlice                `boil:"FDCUsdaFoodComponents" json:"FDCUsdaFoodComponents" toml:"FDCUsdaFoodComponents" yaml:"FDCUsdaFoodComponents"`
	FDCUsdaFoodNutrientConversionFactors UsdaFoodNutrientConversionFactorSlice `boil:"FDCUsdaFoodNutrientConversionFactors" json:"FDCUsdaFoodNutrientConversionFactors" toml:"FDCUsdaFoodNutrientConversionFactors" yaml:"FDCUsdaFoodNutrientConversionFactors"`
	FDCUsdaFoodPortions                  UsdaFoodPortionSlice                  `boil:"FDCUsdaFoodPortions" json:"FDCUsdaFoodPortions" toml:"FDCUsdaFoodPortions" yaml:"FDCUsdaFoodPortions"`
	FDCUsdaInputFoods                    UsdaInputFoodSlice                    `boil:"FDCUsdaInputFoods" json:"FDCUsdaInputFoods" toml:"FDCUsdaInputFoods" yaml:"FDCUsdaInputFoods"`
	FDCIDOfInputFoodUsdaInputFoods       UsdaInputFoodSlice                    `boil:"FDCIDOfInputFoodUsdaInputFoods" json:"FDCIDOfInputFoodUsdaInputFoods" toml:"FDCIDOfInputFoodUsdaInputFoods" yaml:"FDCIDOfInputFoodUsdaInputFoods"`
	FDCIDOfSampleFoodUsdaSubSampleFoods  UsdaSubSampleFoodSlice                `boil:"FDCIDOfSampleFoodUsdaSubSampleFoods" json:"FDCIDOfSampleFoodUsdaSubSampleFoods" toml:"FDCIDOfSampleFoodUsdaSubSampleFoods" yaml:"FDCIDOfSampleFoodUsdaSubSampleFoods"`
}

// NewStruct creates a new relationship struct
func (*usdaFoodR) NewStruct() *usdaFoodR {
	return &usdaFoodR{}
}

// usdaFoodL is where Load methods for each relationship are stored.
type usdaFoodL struct{}

var (
	usdaFoodAllColumns            = []string{"fdc_id", "data_type", "description", "food_category_id", "publication_date"}
	usdaFoodColumnsWithoutDefault = []string{"fdc_id", "data_type", "description", "food_category_id", "publication_date"}
	usdaFoodColumnsWithDefault    = []string{}
	usdaFoodPrimaryKeyColumns     = []string{"fdc_id"}
)

type (
	// UsdaFoodSlice is an alias for a slice of pointers to UsdaFood.
	// This should almost always be used instead of []UsdaFood.
	UsdaFoodSlice []*UsdaFood
	// UsdaFoodHook is the signature for custom UsdaFood hook methods
	UsdaFoodHook func(context.Context, boil.ContextExecutor, *UsdaFood) error

	usdaFoodQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	usdaFoodType                 = reflect.TypeOf(&UsdaFood{})
	usdaFoodMapping              = queries.MakeStructMapping(usdaFoodType)
	usdaFoodPrimaryKeyMapping, _ = queries.BindMapping(usdaFoodType, usdaFoodMapping, usdaFoodPrimaryKeyColumns)
	usdaFoodInsertCacheMut       sync.RWMutex
	usdaFoodInsertCache          = make(map[string]insertCache)
	usdaFoodUpdateCacheMut       sync.RWMutex
	usdaFoodUpdateCache          = make(map[string]updateCache)
	usdaFoodUpsertCacheMut       sync.RWMutex
	usdaFoodUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var usdaFoodBeforeInsertHooks []UsdaFoodHook
var usdaFoodBeforeUpdateHooks []UsdaFoodHook
var usdaFoodBeforeDeleteHooks []UsdaFoodHook
var usdaFoodBeforeUpsertHooks []UsdaFoodHook

var usdaFoodAfterInsertHooks []UsdaFoodHook
var usdaFoodAfterSelectHooks []UsdaFoodHook
var usdaFoodAfterUpdateHooks []UsdaFoodHook
var usdaFoodAfterDeleteHooks []UsdaFoodHook
var usdaFoodAfterUpsertHooks []UsdaFoodHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *UsdaFood) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range usdaFoodBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *UsdaFood) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range usdaFoodBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *UsdaFood) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range usdaFoodBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *UsdaFood) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range usdaFoodBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *UsdaFood) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range usdaFoodAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *UsdaFood) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range usdaFoodAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *UsdaFood) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range usdaFoodAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *UsdaFood) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range usdaFoodAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *UsdaFood) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range usdaFoodAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUsdaFoodHook registers your hook function for all future operations.
func AddUsdaFoodHook(hookPoint boil.HookPoint, usdaFoodHook UsdaFoodHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		usdaFoodBeforeInsertHooks = append(usdaFoodBeforeInsertHooks, usdaFoodHook)
	case boil.BeforeUpdateHook:
		usdaFoodBeforeUpdateHooks = append(usdaFoodBeforeUpdateHooks, usdaFoodHook)
	case boil.BeforeDeleteHook:
		usdaFoodBeforeDeleteHooks = append(usdaFoodBeforeDeleteHooks, usdaFoodHook)
	case boil.BeforeUpsertHook:
		usdaFoodBeforeUpsertHooks = append(usdaFoodBeforeUpsertHooks, usdaFoodHook)
	case boil.AfterInsertHook:
		usdaFoodAfterInsertHooks = append(usdaFoodAfterInsertHooks, usdaFoodHook)
	case boil.AfterSelectHook:
		usdaFoodAfterSelectHooks = append(usdaFoodAfterSelectHooks, usdaFoodHook)
	case boil.AfterUpdateHook:
		usdaFoodAfterUpdateHooks = append(usdaFoodAfterUpdateHooks, usdaFoodHook)
	case boil.AfterDeleteHook:
		usdaFoodAfterDeleteHooks = append(usdaFoodAfterDeleteHooks, usdaFoodHook)
	case boil.AfterUpsertHook:
		usdaFoodAfterUpsertHooks = append(usdaFoodAfterUpsertHooks, usdaFoodHook)
	}
}

// One returns a single usdaFood record from the query.
func (q usdaFoodQuery) One(ctx context.Context, exec boil.ContextExecutor) (*UsdaFood, error) {
	o := &UsdaFood{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for usda_food")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all UsdaFood records from the query.
func (q usdaFoodQuery) All(ctx context.Context, exec boil.ContextExecutor) (UsdaFoodSlice, error) {
	var o []*UsdaFood

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to UsdaFood slice")
	}

	if len(usdaFoodAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all UsdaFood records in the query.
func (q usdaFoodQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count usda_food rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q usdaFoodQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if usda_food exists")
	}

	return count > 0, nil
}

// FDCUsdaBrandedFood pointed to by the foreign key.
func (o *UsdaFood) FDCUsdaBrandedFood(mods ...qm.QueryMod) usdaBrandedFoodQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"fdc_id\" = ?", o.FDCID),
	}

	queryMods = append(queryMods, mods...)

	query := UsdaBrandedFoods(queryMods...)
	queries.SetFrom(query.Query, "\"usda_branded_food\"")

	return query
}

// FDCUsdaFoundationFood pointed to by the foreign key.
func (o *UsdaFood) FDCUsdaFoundationFood(mods ...qm.QueryMod) usdaFoundationFoodQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"fdc_id\" = ?", o.FDCID),
	}

	queryMods = append(queryMods, mods...)

	query := UsdaFoundationFoods(queryMods...)
	queries.SetFrom(query.Query, "\"usda_foundation_food\"")

	return query
}

// FDCUsdaMarketAcquisition pointed to by the foreign key.
func (o *UsdaFood) FDCUsdaMarketAcquisition(mods ...qm.QueryMod) usdaMarketAcquisitionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"fdc_id\" = ?", o.FDCID),
	}

	queryMods = append(queryMods, mods...)

	query := UsdaMarketAcquisitions(queryMods...)
	queries.SetFrom(query.Query, "\"usda_market_acquisition\"")

	return query
}

// FDCUsdaSampleFood pointed to by the foreign key.
func (o *UsdaFood) FDCUsdaSampleFood(mods ...qm.QueryMod) usdaSampleFoodQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"fdc_id\" = ?", o.FDCID),
	}

	queryMods = append(queryMods, mods...)

	query := UsdaSampleFoods(queryMods...)
	queries.SetFrom(query.Query, "\"usda_sample_food\"")

	return query
}

// FDCUsdaSRLegacyFood pointed to by the foreign key.
func (o *UsdaFood) FDCUsdaSRLegacyFood(mods ...qm.QueryMod) usdaSRLegacyFoodQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"fdc_id\" = ?", o.FDCID),
	}

	queryMods = append(queryMods, mods...)

	query := UsdaSRLegacyFoods(queryMods...)
	queries.SetFrom(query.Query, "\"usda_sr_legacy_food\"")

	return query
}

// FDCUsdaSubSampleFood pointed to by the foreign key.
func (o *UsdaFood) FDCUsdaSubSampleFood(mods ...qm.QueryMod) usdaSubSampleFoodQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"fdc_id\" = ?", o.FDCID),
	}

	queryMods = append(queryMods, mods...)

	query := UsdaSubSampleFoods(queryMods...)
	queries.SetFrom(query.Query, "\"usda_sub_sample_food\"")

	return query
}

// FDCUsdaSurveyFNDDSFood pointed to by the foreign key.
func (o *UsdaFood) FDCUsdaSurveyFNDDSFood(mods ...qm.QueryMod) usdaSurveyFNDDSFoodQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"fdc_id\" = ?", o.FDCID),
	}

	queryMods = append(queryMods, mods...)

	query := UsdaSurveyFNDDSFoods(queryMods...)
	queries.SetFrom(query.Query, "\"usda_survey_fndds_food\"")

	return query
}

// FDCIDOfSampleFoodUsdaFoods retrieves all the usda_food's UsdaFoods with an executor via fdc_id column.
func (o *UsdaFood) FDCIDOfSampleFoodUsdaFoods(mods ...qm.QueryMod) usdaFoodQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("\"usda_acquisition_sample\" on \"usda_food\".\"fdc_id\" = \"usda_acquisition_sample\".\"fdc_id_of_sample_food\""),
		qm.Where("\"usda_acquisition_sample\".\"fdc_id_of_acquisition_food\"=?", o.FDCID),
	)

	query := UsdaFoods(queryMods...)
	queries.SetFrom(query.Query, "\"usda_food\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"usda_food\".*"})
	}

	return query
}

// FDCIDOfAcquisitionFoodUsdaFoods retrieves all the usda_food's UsdaFoods with an executor via fdc_id column.
func (o *UsdaFood) FDCIDOfAcquisitionFoodUsdaFoods(mods ...qm.QueryMod) usdaFoodQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("\"usda_acquisition_sample\" on \"usda_food\".\"fdc_id\" = \"usda_acquisition_sample\".\"fdc_id_of_acquisition_food\""),
		qm.Where("\"usda_acquisition_sample\".\"fdc_id_of_sample_food\"=?", o.FDCID),
	)

	query := UsdaFoods(queryMods...)
	queries.SetFrom(query.Query, "\"usda_food\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"usda_food\".*"})
	}

	return query
}

// FDCUsdaFoodAttributes retrieves all the usda_food_attribute's UsdaFoodAttributes with an executor via fdc_id column.
func (o *UsdaFood) FDCUsdaFoodAttributes(mods ...qm.QueryMod) usdaFoodAttributeQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"usda_food_attribute\".\"fdc_id\"=?", o.FDCID),
	)

	query := UsdaFoodAttributes(queryMods...)
	queries.SetFrom(query.Query, "\"usda_food_attribute\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"usda_food_attribute\".*"})
	}

	return query
}

// FDCUsdaFoodComponents retrieves all the usda_food_component's UsdaFoodComponents with an executor via fdc_id column.
func (o *UsdaFood) FDCUsdaFoodComponents(mods ...qm.QueryMod) usdaFoodComponentQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"usda_food_component\".\"fdc_id\"=?", o.FDCID),
	)

	query := UsdaFoodComponents(queryMods...)
	queries.SetFrom(query.Query, "\"usda_food_component\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"usda_food_component\".*"})
	}

	return query
}

// FDCUsdaFoodNutrientConversionFactors retrieves all the usda_food_nutrient_conversion_factor's UsdaFoodNutrientConversionFactors with an executor via fdc_id column.
func (o *UsdaFood) FDCUsdaFoodNutrientConversionFactors(mods ...qm.QueryMod) usdaFoodNutrientConversionFactorQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"usda_food_nutrient_conversion_factor\".\"fdc_id\"=?", o.FDCID),
	)

	query := UsdaFoodNutrientConversionFactors(queryMods...)
	queries.SetFrom(query.Query, "\"usda_food_nutrient_conversion_factor\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"usda_food_nutrient_conversion_factor\".*"})
	}

	return query
}

// FDCUsdaFoodPortions retrieves all the usda_food_portion's UsdaFoodPortions with an executor via fdc_id column.
func (o *UsdaFood) FDCUsdaFoodPortions(mods ...qm.QueryMod) usdaFoodPortionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"usda_food_portion\".\"fdc_id\"=?", o.FDCID),
	)

	query := UsdaFoodPortions(queryMods...)
	queries.SetFrom(query.Query, "\"usda_food_portion\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"usda_food_portion\".*"})
	}

	return query
}

// FDCUsdaInputFoods retrieves all the usda_input_food's UsdaInputFoods with an executor via fdc_id column.
func (o *UsdaFood) FDCUsdaInputFoods(mods ...qm.QueryMod) usdaInputFoodQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"usda_input_food\".\"fdc_id\"=?", o.FDCID),
	)

	query := UsdaInputFoods(queryMods...)
	queries.SetFrom(query.Query, "\"usda_input_food\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"usda_input_food\".*"})
	}

	return query
}

// FDCIDOfInputFoodUsdaInputFoods retrieves all the usda_input_food's UsdaInputFoods with an executor via fdc_id_of_input_food column.
func (o *UsdaFood) FDCIDOfInputFoodUsdaInputFoods(mods ...qm.QueryMod) usdaInputFoodQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"usda_input_food\".\"fdc_id_of_input_food\"=?", o.FDCID),
	)

	query := UsdaInputFoods(queryMods...)
	queries.SetFrom(query.Query, "\"usda_input_food\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"usda_input_food\".*"})
	}

	return query
}

// FDCIDOfSampleFoodUsdaSubSampleFoods retrieves all the usda_sub_sample_food's UsdaSubSampleFoods with an executor via fdc_id_of_sample_food column.
func (o *UsdaFood) FDCIDOfSampleFoodUsdaSubSampleFoods(mods ...qm.QueryMod) usdaSubSampleFoodQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"usda_sub_sample_food\".\"fdc_id_of_sample_food\"=?", o.FDCID),
	)

	query := UsdaSubSampleFoods(queryMods...)
	queries.SetFrom(query.Query, "\"usda_sub_sample_food\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"usda_sub_sample_food\".*"})
	}

	return query
}

// LoadFDCUsdaBrandedFood allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (usdaFoodL) LoadFDCUsdaBrandedFood(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if a == obj.FDCID {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_branded_food`),
		qm.WhereIn(`usda_branded_food.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load UsdaBrandedFood")
	}

	var resultSlice []*UsdaBrandedFood
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice UsdaBrandedFood")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for usda_branded_food")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_branded_food")
	}

	if len(usdaFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FDCUsdaBrandedFood = foreign
		if foreign.R == nil {
			foreign.R = &usdaBrandedFoodR{}
		}
		foreign.R.FDC = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FDCID == foreign.FDCID {
				local.R.FDCUsdaBrandedFood = foreign
				if foreign.R == nil {
					foreign.R = &usdaBrandedFoodR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCUsdaFoundationFood allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (usdaFoodL) LoadFDCUsdaFoundationFood(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if a == obj.FDCID {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_foundation_food`),
		qm.WhereIn(`usda_foundation_food.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load UsdaFoundationFood")
	}

	var resultSlice []*UsdaFoundationFood
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice UsdaFoundationFood")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for usda_foundation_food")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_foundation_food")
	}

	if len(usdaFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FDCUsdaFoundationFood = foreign
		if foreign.R == nil {
			foreign.R = &usdaFoundationFoodR{}
		}
		foreign.R.FDC = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FDCID == foreign.FDCID {
				local.R.FDCUsdaFoundationFood = foreign
				if foreign.R == nil {
					foreign.R = &usdaFoundationFoodR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCUsdaMarketAcquisition allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (usdaFoodL) LoadFDCUsdaMarketAcquisition(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if a == obj.FDCID {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_market_acquisition`),
		qm.WhereIn(`usda_market_acquisition.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load UsdaMarketAcquisition")
	}

	var resultSlice []*UsdaMarketAcquisition
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice UsdaMarketAcquisition")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for usda_market_acquisition")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_market_acquisition")
	}

	if len(usdaFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FDCUsdaMarketAcquisition = foreign
		if foreign.R == nil {
			foreign.R = &usdaMarketAcquisitionR{}
		}
		foreign.R.FDC = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FDCID == foreign.FDCID {
				local.R.FDCUsdaMarketAcquisition = foreign
				if foreign.R == nil {
					foreign.R = &usdaMarketAcquisitionR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCUsdaSampleFood allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (usdaFoodL) LoadFDCUsdaSampleFood(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if a == obj.FDCID {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_sample_food`),
		qm.WhereIn(`usda_sample_food.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load UsdaSampleFood")
	}

	var resultSlice []*UsdaSampleFood
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice UsdaSampleFood")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for usda_sample_food")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_sample_food")
	}

	if len(usdaFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FDCUsdaSampleFood = foreign
		if foreign.R == nil {
			foreign.R = &usdaSampleFoodR{}
		}
		foreign.R.FDC = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FDCID == foreign.FDCID {
				local.R.FDCUsdaSampleFood = foreign
				if foreign.R == nil {
					foreign.R = &usdaSampleFoodR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCUsdaSRLegacyFood allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (usdaFoodL) LoadFDCUsdaSRLegacyFood(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if a == obj.FDCID {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_sr_legacy_food`),
		qm.WhereIn(`usda_sr_legacy_food.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load UsdaSRLegacyFood")
	}

	var resultSlice []*UsdaSRLegacyFood
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice UsdaSRLegacyFood")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for usda_sr_legacy_food")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_sr_legacy_food")
	}

	if len(usdaFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FDCUsdaSRLegacyFood = foreign
		if foreign.R == nil {
			foreign.R = &usdaSRLegacyFoodR{}
		}
		foreign.R.FDC = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FDCID == foreign.FDCID {
				local.R.FDCUsdaSRLegacyFood = foreign
				if foreign.R == nil {
					foreign.R = &usdaSRLegacyFoodR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCUsdaSubSampleFood allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (usdaFoodL) LoadFDCUsdaSubSampleFood(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if a == obj.FDCID {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_sub_sample_food`),
		qm.WhereIn(`usda_sub_sample_food.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load UsdaSubSampleFood")
	}

	var resultSlice []*UsdaSubSampleFood
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice UsdaSubSampleFood")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for usda_sub_sample_food")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_sub_sample_food")
	}

	if len(usdaFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FDCUsdaSubSampleFood = foreign
		if foreign.R == nil {
			foreign.R = &usdaSubSampleFoodR{}
		}
		foreign.R.FDC = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FDCID == foreign.FDCID {
				local.R.FDCUsdaSubSampleFood = foreign
				if foreign.R == nil {
					foreign.R = &usdaSubSampleFoodR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCUsdaSurveyFNDDSFood allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (usdaFoodL) LoadFDCUsdaSurveyFNDDSFood(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if a == obj.FDCID {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_survey_fndds_food`),
		qm.WhereIn(`usda_survey_fndds_food.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load UsdaSurveyFNDDSFood")
	}

	var resultSlice []*UsdaSurveyFNDDSFood
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice UsdaSurveyFNDDSFood")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for usda_survey_fndds_food")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_survey_fndds_food")
	}

	if len(usdaFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.FDCUsdaSurveyFNDDSFood = foreign
		if foreign.R == nil {
			foreign.R = &usdaSurveyFNDDSFoodR{}
		}
		foreign.R.FDC = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FDCID == foreign.FDCID {
				local.R.FDCUsdaSurveyFNDDSFood = foreign
				if foreign.R == nil {
					foreign.R = &usdaSurveyFNDDSFoodR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCIDOfSampleFoodUsdaFoods allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (usdaFoodL) LoadFDCIDOfSampleFoodUsdaFoods(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if a == obj.FDCID {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("\"usda_food\".fdc_id, \"usda_food\".data_type, \"usda_food\".description, \"usda_food\".food_category_id, \"usda_food\".publication_date, \"a\".\"fdc_id_of_acquisition_food\""),
		qm.From("\"usda_food\""),
		qm.InnerJoin("\"usda_acquisition_sample\" as \"a\" on \"usda_food\".\"fdc_id\" = \"a\".\"fdc_id_of_sample_food\""),
		qm.WhereIn("\"a\".\"fdc_id_of_acquisition_food\" in ?", args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load usda_food")
	}

	var resultSlice []*UsdaFood

	var localJoinCols []int
	for results.Next() {
		one := new(UsdaFood)
		var localJoinCol int

		err = results.Scan(&one.FDCID, &one.DataType, &one.Description, &one.FoodCategoryID, &one.PublicationDate, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for usda_food")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice usda_food")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on usda_food")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_food")
	}

	if len(usdaFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FDCIDOfSampleFoodUsdaFoods = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &usdaFoodR{}
			}
			foreign.R.FDCIDOfAcquisitionFoodUsdaFoods = append(foreign.R.FDCIDOfAcquisitionFoodUsdaFoods, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.FDCID == localJoinCol {
				local.R.FDCIDOfSampleFoodUsdaFoods = append(local.R.FDCIDOfSampleFoodUsdaFoods, foreign)
				if foreign.R == nil {
					foreign.R = &usdaFoodR{}
				}
				foreign.R.FDCIDOfAcquisitionFoodUsdaFoods = append(foreign.R.FDCIDOfAcquisitionFoodUsdaFoods, local)
				break
			}
		}
	}

	return nil
}

// LoadFDCIDOfAcquisitionFoodUsdaFoods allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (usdaFoodL) LoadFDCIDOfAcquisitionFoodUsdaFoods(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if a == obj.FDCID {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.Select("\"usda_food\".fdc_id, \"usda_food\".data_type, \"usda_food\".description, \"usda_food\".food_category_id, \"usda_food\".publication_date, \"a\".\"fdc_id_of_sample_food\""),
		qm.From("\"usda_food\""),
		qm.InnerJoin("\"usda_acquisition_sample\" as \"a\" on \"usda_food\".\"fdc_id\" = \"a\".\"fdc_id_of_acquisition_food\""),
		qm.WhereIn("\"a\".\"fdc_id_of_sample_food\" in ?", args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load usda_food")
	}

	var resultSlice []*UsdaFood

	var localJoinCols []int
	for results.Next() {
		one := new(UsdaFood)
		var localJoinCol int

		err = results.Scan(&one.FDCID, &one.DataType, &one.Description, &one.FoodCategoryID, &one.PublicationDate, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for usda_food")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice usda_food")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on usda_food")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_food")
	}

	if len(usdaFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FDCIDOfAcquisitionFoodUsdaFoods = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &usdaFoodR{}
			}
			foreign.R.FDCIDOfSampleFoodUsdaFoods = append(foreign.R.FDCIDOfSampleFoodUsdaFoods, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.FDCID == localJoinCol {
				local.R.FDCIDOfAcquisitionFoodUsdaFoods = append(local.R.FDCIDOfAcquisitionFoodUsdaFoods, foreign)
				if foreign.R == nil {
					foreign.R = &usdaFoodR{}
				}
				foreign.R.FDCIDOfSampleFoodUsdaFoods = append(foreign.R.FDCIDOfSampleFoodUsdaFoods, local)
				break
			}
		}
	}

	return nil
}

// LoadFDCUsdaFoodAttributes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (usdaFoodL) LoadFDCUsdaFoodAttributes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.FDCID) {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_food_attribute`),
		qm.WhereIn(`usda_food_attribute.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load usda_food_attribute")
	}

	var resultSlice []*UsdaFoodAttribute
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice usda_food_attribute")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on usda_food_attribute")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_food_attribute")
	}

	if len(usdaFoodAttributeAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FDCUsdaFoodAttributes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &usdaFoodAttributeR{}
			}
			foreign.R.FDC = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.FDCID, foreign.FDCID) {
				local.R.FDCUsdaFoodAttributes = append(local.R.FDCUsdaFoodAttributes, foreign)
				if foreign.R == nil {
					foreign.R = &usdaFoodAttributeR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCUsdaFoodComponents allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (usdaFoodL) LoadFDCUsdaFoodComponents(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.FDCID) {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_food_component`),
		qm.WhereIn(`usda_food_component.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load usda_food_component")
	}

	var resultSlice []*UsdaFoodComponent
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice usda_food_component")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on usda_food_component")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_food_component")
	}

	if len(usdaFoodComponentAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FDCUsdaFoodComponents = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &usdaFoodComponentR{}
			}
			foreign.R.FDC = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.FDCID, foreign.FDCID) {
				local.R.FDCUsdaFoodComponents = append(local.R.FDCUsdaFoodComponents, foreign)
				if foreign.R == nil {
					foreign.R = &usdaFoodComponentR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCUsdaFoodNutrientConversionFactors allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (usdaFoodL) LoadFDCUsdaFoodNutrientConversionFactors(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.FDCID) {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_food_nutrient_conversion_factor`),
		qm.WhereIn(`usda_food_nutrient_conversion_factor.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load usda_food_nutrient_conversion_factor")
	}

	var resultSlice []*UsdaFoodNutrientConversionFactor
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice usda_food_nutrient_conversion_factor")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on usda_food_nutrient_conversion_factor")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_food_nutrient_conversion_factor")
	}

	if len(usdaFoodNutrientConversionFactorAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FDCUsdaFoodNutrientConversionFactors = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &usdaFoodNutrientConversionFactorR{}
			}
			foreign.R.FDC = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.FDCID, foreign.FDCID) {
				local.R.FDCUsdaFoodNutrientConversionFactors = append(local.R.FDCUsdaFoodNutrientConversionFactors, foreign)
				if foreign.R == nil {
					foreign.R = &usdaFoodNutrientConversionFactorR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCUsdaFoodPortions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (usdaFoodL) LoadFDCUsdaFoodPortions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.FDCID) {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_food_portion`),
		qm.WhereIn(`usda_food_portion.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load usda_food_portion")
	}

	var resultSlice []*UsdaFoodPortion
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice usda_food_portion")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on usda_food_portion")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_food_portion")
	}

	if len(usdaFoodPortionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FDCUsdaFoodPortions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &usdaFoodPortionR{}
			}
			foreign.R.FDC = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.FDCID, foreign.FDCID) {
				local.R.FDCUsdaFoodPortions = append(local.R.FDCUsdaFoodPortions, foreign)
				if foreign.R == nil {
					foreign.R = &usdaFoodPortionR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCUsdaInputFoods allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (usdaFoodL) LoadFDCUsdaInputFoods(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.FDCID) {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_input_food`),
		qm.WhereIn(`usda_input_food.fdc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load usda_input_food")
	}

	var resultSlice []*UsdaInputFood
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice usda_input_food")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on usda_input_food")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_input_food")
	}

	if len(usdaInputFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FDCUsdaInputFoods = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &usdaInputFoodR{}
			}
			foreign.R.FDC = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.FDCID, foreign.FDCID) {
				local.R.FDCUsdaInputFoods = append(local.R.FDCUsdaInputFoods, foreign)
				if foreign.R == nil {
					foreign.R = &usdaInputFoodR{}
				}
				foreign.R.FDC = local
				break
			}
		}
	}

	return nil
}

// LoadFDCIDOfInputFoodUsdaInputFoods allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (usdaFoodL) LoadFDCIDOfInputFoodUsdaInputFoods(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.FDCID) {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_input_food`),
		qm.WhereIn(`usda_input_food.fdc_id_of_input_food in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load usda_input_food")
	}

	var resultSlice []*UsdaInputFood
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice usda_input_food")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on usda_input_food")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_input_food")
	}

	if len(usdaInputFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FDCIDOfInputFoodUsdaInputFoods = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &usdaInputFoodR{}
			}
			foreign.R.FDCIDOfInputFoodUsdaFood = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.FDCID, foreign.FDCIDOfInputFood) {
				local.R.FDCIDOfInputFoodUsdaInputFoods = append(local.R.FDCIDOfInputFoodUsdaInputFoods, foreign)
				if foreign.R == nil {
					foreign.R = &usdaInputFoodR{}
				}
				foreign.R.FDCIDOfInputFoodUsdaFood = local
				break
			}
		}
	}

	return nil
}

// LoadFDCIDOfSampleFoodUsdaSubSampleFoods allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (usdaFoodL) LoadFDCIDOfSampleFoodUsdaSubSampleFoods(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUsdaFood interface{}, mods queries.Applicator) error {
	var slice []*UsdaFood
	var object *UsdaFood

	if singular {
		object = maybeUsdaFood.(*UsdaFood)
	} else {
		slice = *maybeUsdaFood.(*[]*UsdaFood)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &usdaFoodR{}
		}
		args = append(args, object.FDCID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &usdaFoodR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.FDCID) {
					continue Outer
				}
			}

			args = append(args, obj.FDCID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`usda_sub_sample_food`),
		qm.WhereIn(`usda_sub_sample_food.fdc_id_of_sample_food in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load usda_sub_sample_food")
	}

	var resultSlice []*UsdaSubSampleFood
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice usda_sub_sample_food")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on usda_sub_sample_food")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for usda_sub_sample_food")
	}

	if len(usdaSubSampleFoodAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.FDCIDOfSampleFoodUsdaSubSampleFoods = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &usdaSubSampleFoodR{}
			}
			foreign.R.FDCIDOfSampleFoodUsdaFood = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.FDCID, foreign.FDCIDOfSampleFood) {
				local.R.FDCIDOfSampleFoodUsdaSubSampleFoods = append(local.R.FDCIDOfSampleFoodUsdaSubSampleFoods, foreign)
				if foreign.R == nil {
					foreign.R = &usdaSubSampleFoodR{}
				}
				foreign.R.FDCIDOfSampleFoodUsdaFood = local
				break
			}
		}
	}

	return nil
}

// SetFDCUsdaBrandedFood of the usdaFood to the related item.
// Sets o.R.FDCUsdaBrandedFood to related.
// Adds o to related.R.FDC.
func (o *UsdaFood) SetFDCUsdaBrandedFood(ctx context.Context, exec boil.ContextExecutor, insert bool, related *UsdaBrandedFood) error {
	var err error

	if insert {
		related.FDCID = o.FDCID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"usda_branded_food\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
			strmangle.WhereClause("\"", "\"", 2, usdaBrandedFoodPrimaryKeyColumns),
		)
		values := []interface{}{o.FDCID, related.FDCID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.FDCID = o.FDCID

	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaBrandedFood: related,
		}
	} else {
		o.R.FDCUsdaBrandedFood = related
	}

	if related.R == nil {
		related.R = &usdaBrandedFoodR{
			FDC: o,
		}
	} else {
		related.R.FDC = o
	}
	return nil
}

// SetFDCUsdaFoundationFood of the usdaFood to the related item.
// Sets o.R.FDCUsdaFoundationFood to related.
// Adds o to related.R.FDC.
func (o *UsdaFood) SetFDCUsdaFoundationFood(ctx context.Context, exec boil.ContextExecutor, insert bool, related *UsdaFoundationFood) error {
	var err error

	if insert {
		related.FDCID = o.FDCID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"usda_foundation_food\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
			strmangle.WhereClause("\"", "\"", 2, usdaFoundationFoodPrimaryKeyColumns),
		)
		values := []interface{}{o.FDCID, related.FDCID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.FDCID = o.FDCID

	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaFoundationFood: related,
		}
	} else {
		o.R.FDCUsdaFoundationFood = related
	}

	if related.R == nil {
		related.R = &usdaFoundationFoodR{
			FDC: o,
		}
	} else {
		related.R.FDC = o
	}
	return nil
}

// SetFDCUsdaMarketAcquisition of the usdaFood to the related item.
// Sets o.R.FDCUsdaMarketAcquisition to related.
// Adds o to related.R.FDC.
func (o *UsdaFood) SetFDCUsdaMarketAcquisition(ctx context.Context, exec boil.ContextExecutor, insert bool, related *UsdaMarketAcquisition) error {
	var err error

	if insert {
		related.FDCID = o.FDCID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"usda_market_acquisition\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
			strmangle.WhereClause("\"", "\"", 2, usdaMarketAcquisitionPrimaryKeyColumns),
		)
		values := []interface{}{o.FDCID, related.FDCID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.FDCID = o.FDCID

	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaMarketAcquisition: related,
		}
	} else {
		o.R.FDCUsdaMarketAcquisition = related
	}

	if related.R == nil {
		related.R = &usdaMarketAcquisitionR{
			FDC: o,
		}
	} else {
		related.R.FDC = o
	}
	return nil
}

// SetFDCUsdaSampleFood of the usdaFood to the related item.
// Sets o.R.FDCUsdaSampleFood to related.
// Adds o to related.R.FDC.
func (o *UsdaFood) SetFDCUsdaSampleFood(ctx context.Context, exec boil.ContextExecutor, insert bool, related *UsdaSampleFood) error {
	var err error

	if insert {
		related.FDCID = o.FDCID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"usda_sample_food\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
			strmangle.WhereClause("\"", "\"", 2, usdaSampleFoodPrimaryKeyColumns),
		)
		values := []interface{}{o.FDCID, related.FDCID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.FDCID = o.FDCID

	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaSampleFood: related,
		}
	} else {
		o.R.FDCUsdaSampleFood = related
	}

	if related.R == nil {
		related.R = &usdaSampleFoodR{
			FDC: o,
		}
	} else {
		related.R.FDC = o
	}
	return nil
}

// SetFDCUsdaSRLegacyFood of the usdaFood to the related item.
// Sets o.R.FDCUsdaSRLegacyFood to related.
// Adds o to related.R.FDC.
func (o *UsdaFood) SetFDCUsdaSRLegacyFood(ctx context.Context, exec boil.ContextExecutor, insert bool, related *UsdaSRLegacyFood) error {
	var err error

	if insert {
		related.FDCID = o.FDCID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"usda_sr_legacy_food\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
			strmangle.WhereClause("\"", "\"", 2, usdaSRLegacyFoodPrimaryKeyColumns),
		)
		values := []interface{}{o.FDCID, related.FDCID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.FDCID = o.FDCID

	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaSRLegacyFood: related,
		}
	} else {
		o.R.FDCUsdaSRLegacyFood = related
	}

	if related.R == nil {
		related.R = &usdaSRLegacyFoodR{
			FDC: o,
		}
	} else {
		related.R.FDC = o
	}
	return nil
}

// SetFDCUsdaSubSampleFood of the usdaFood to the related item.
// Sets o.R.FDCUsdaSubSampleFood to related.
// Adds o to related.R.FDC.
func (o *UsdaFood) SetFDCUsdaSubSampleFood(ctx context.Context, exec boil.ContextExecutor, insert bool, related *UsdaSubSampleFood) error {
	var err error

	if insert {
		related.FDCID = o.FDCID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"usda_sub_sample_food\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
			strmangle.WhereClause("\"", "\"", 2, usdaSubSampleFoodPrimaryKeyColumns),
		)
		values := []interface{}{o.FDCID, related.FDCID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.FDCID = o.FDCID

	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaSubSampleFood: related,
		}
	} else {
		o.R.FDCUsdaSubSampleFood = related
	}

	if related.R == nil {
		related.R = &usdaSubSampleFoodR{
			FDC: o,
		}
	} else {
		related.R.FDC = o
	}
	return nil
}

// SetFDCUsdaSurveyFNDDSFood of the usdaFood to the related item.
// Sets o.R.FDCUsdaSurveyFNDDSFood to related.
// Adds o to related.R.FDC.
func (o *UsdaFood) SetFDCUsdaSurveyFNDDSFood(ctx context.Context, exec boil.ContextExecutor, insert bool, related *UsdaSurveyFNDDSFood) error {
	var err error

	if insert {
		related.FDCID = o.FDCID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"usda_survey_fndds_food\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
			strmangle.WhereClause("\"", "\"", 2, usdaSurveyFNDDSFoodPrimaryKeyColumns),
		)
		values := []interface{}{o.FDCID, related.FDCID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.FDCID = o.FDCID

	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaSurveyFNDDSFood: related,
		}
	} else {
		o.R.FDCUsdaSurveyFNDDSFood = related
	}

	if related.R == nil {
		related.R = &usdaSurveyFNDDSFoodR{
			FDC: o,
		}
	} else {
		related.R.FDC = o
	}
	return nil
}

// AddFDCIDOfSampleFoodUsdaFoods adds the given related objects to the existing relationships
// of the usda_food, optionally inserting them as new records.
// Appends related to o.R.FDCIDOfSampleFoodUsdaFoods.
// Sets related.R.FDCIDOfAcquisitionFoodUsdaFoods appropriately.
func (o *UsdaFood) AddFDCIDOfSampleFoodUsdaFoods(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFood) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into \"usda_acquisition_sample\" (\"fdc_id_of_acquisition_food\", \"fdc_id_of_sample_food\") values ($1, $2)"
		values := []interface{}{o.FDCID, rel.FDCID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, query)
			fmt.Fprintln(writer, values)
		}
		_, err = exec.ExecContext(ctx, query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &usdaFoodR{
			FDCIDOfSampleFoodUsdaFoods: related,
		}
	} else {
		o.R.FDCIDOfSampleFoodUsdaFoods = append(o.R.FDCIDOfSampleFoodUsdaFoods, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &usdaFoodR{
				FDCIDOfAcquisitionFoodUsdaFoods: UsdaFoodSlice{o},
			}
		} else {
			rel.R.FDCIDOfAcquisitionFoodUsdaFoods = append(rel.R.FDCIDOfAcquisitionFoodUsdaFoods, o)
		}
	}
	return nil
}

// SetFDCIDOfSampleFoodUsdaFoods removes all previously related items of the
// usda_food replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.FDCIDOfAcquisitionFoodUsdaFoods's FDCIDOfSampleFoodUsdaFoods accordingly.
// Replaces o.R.FDCIDOfSampleFoodUsdaFoods with related.
// Sets related.R.FDCIDOfAcquisitionFoodUsdaFoods's FDCIDOfSampleFoodUsdaFoods accordingly.
func (o *UsdaFood) SetFDCIDOfSampleFoodUsdaFoods(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFood) error {
	query := "delete from \"usda_acquisition_sample\" where \"fdc_id_of_acquisition_food\" = $1"
	values := []interface{}{o.FDCID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeFDCIDOfSampleFoodUsdaFoodsFromFDCIDOfAcquisitionFoodUsdaFoodsSlice(o, related)
	if o.R != nil {
		o.R.FDCIDOfSampleFoodUsdaFoods = nil
	}
	return o.AddFDCIDOfSampleFoodUsdaFoods(ctx, exec, insert, related...)
}

// RemoveFDCIDOfSampleFoodUsdaFoods relationships from objects passed in.
// Removes related items from R.FDCIDOfSampleFoodUsdaFoods (uses pointer comparison, removal does not keep order)
// Sets related.R.FDCIDOfAcquisitionFoodUsdaFoods.
func (o *UsdaFood) RemoveFDCIDOfSampleFoodUsdaFoods(ctx context.Context, exec boil.ContextExecutor, related ...*UsdaFood) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from \"usda_acquisition_sample\" where \"fdc_id_of_acquisition_food\" = $1 and \"fdc_id_of_sample_food\" in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.FDCID}
	for _, rel := range related {
		values = append(values, rel.FDCID)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeFDCIDOfSampleFoodUsdaFoodsFromFDCIDOfAcquisitionFoodUsdaFoodsSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FDCIDOfSampleFoodUsdaFoods {
			if rel != ri {
				continue
			}

			ln := len(o.R.FDCIDOfSampleFoodUsdaFoods)
			if ln > 1 && i < ln-1 {
				o.R.FDCIDOfSampleFoodUsdaFoods[i] = o.R.FDCIDOfSampleFoodUsdaFoods[ln-1]
			}
			o.R.FDCIDOfSampleFoodUsdaFoods = o.R.FDCIDOfSampleFoodUsdaFoods[:ln-1]
			break
		}
	}

	return nil
}

func removeFDCIDOfSampleFoodUsdaFoodsFromFDCIDOfAcquisitionFoodUsdaFoodsSlice(o *UsdaFood, related []*UsdaFood) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.FDCIDOfAcquisitionFoodUsdaFoods {
			if o.FDCID != ri.FDCID {
				continue
			}

			ln := len(rel.R.FDCIDOfAcquisitionFoodUsdaFoods)
			if ln > 1 && i < ln-1 {
				rel.R.FDCIDOfAcquisitionFoodUsdaFoods[i] = rel.R.FDCIDOfAcquisitionFoodUsdaFoods[ln-1]
			}
			rel.R.FDCIDOfAcquisitionFoodUsdaFoods = rel.R.FDCIDOfAcquisitionFoodUsdaFoods[:ln-1]
			break
		}
	}
}

// AddFDCIDOfAcquisitionFoodUsdaFoods adds the given related objects to the existing relationships
// of the usda_food, optionally inserting them as new records.
// Appends related to o.R.FDCIDOfAcquisitionFoodUsdaFoods.
// Sets related.R.FDCIDOfSampleFoodUsdaFoods appropriately.
func (o *UsdaFood) AddFDCIDOfAcquisitionFoodUsdaFoods(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFood) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into \"usda_acquisition_sample\" (\"fdc_id_of_sample_food\", \"fdc_id_of_acquisition_food\") values ($1, $2)"
		values := []interface{}{o.FDCID, rel.FDCID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, query)
			fmt.Fprintln(writer, values)
		}
		_, err = exec.ExecContext(ctx, query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &usdaFoodR{
			FDCIDOfAcquisitionFoodUsdaFoods: related,
		}
	} else {
		o.R.FDCIDOfAcquisitionFoodUsdaFoods = append(o.R.FDCIDOfAcquisitionFoodUsdaFoods, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &usdaFoodR{
				FDCIDOfSampleFoodUsdaFoods: UsdaFoodSlice{o},
			}
		} else {
			rel.R.FDCIDOfSampleFoodUsdaFoods = append(rel.R.FDCIDOfSampleFoodUsdaFoods, o)
		}
	}
	return nil
}

// SetFDCIDOfAcquisitionFoodUsdaFoods removes all previously related items of the
// usda_food replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.FDCIDOfSampleFoodUsdaFoods's FDCIDOfAcquisitionFoodUsdaFoods accordingly.
// Replaces o.R.FDCIDOfAcquisitionFoodUsdaFoods with related.
// Sets related.R.FDCIDOfSampleFoodUsdaFoods's FDCIDOfAcquisitionFoodUsdaFoods accordingly.
func (o *UsdaFood) SetFDCIDOfAcquisitionFoodUsdaFoods(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFood) error {
	query := "delete from \"usda_acquisition_sample\" where \"fdc_id_of_sample_food\" = $1"
	values := []interface{}{o.FDCID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeFDCIDOfAcquisitionFoodUsdaFoodsFromFDCIDOfSampleFoodUsdaFoodsSlice(o, related)
	if o.R != nil {
		o.R.FDCIDOfAcquisitionFoodUsdaFoods = nil
	}
	return o.AddFDCIDOfAcquisitionFoodUsdaFoods(ctx, exec, insert, related...)
}

// RemoveFDCIDOfAcquisitionFoodUsdaFoods relationships from objects passed in.
// Removes related items from R.FDCIDOfAcquisitionFoodUsdaFoods (uses pointer comparison, removal does not keep order)
// Sets related.R.FDCIDOfSampleFoodUsdaFoods.
func (o *UsdaFood) RemoveFDCIDOfAcquisitionFoodUsdaFoods(ctx context.Context, exec boil.ContextExecutor, related ...*UsdaFood) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from \"usda_acquisition_sample\" where \"fdc_id_of_sample_food\" = $1 and \"fdc_id_of_acquisition_food\" in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.FDCID}
	for _, rel := range related {
		values = append(values, rel.FDCID)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeFDCIDOfAcquisitionFoodUsdaFoodsFromFDCIDOfSampleFoodUsdaFoodsSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FDCIDOfAcquisitionFoodUsdaFoods {
			if rel != ri {
				continue
			}

			ln := len(o.R.FDCIDOfAcquisitionFoodUsdaFoods)
			if ln > 1 && i < ln-1 {
				o.R.FDCIDOfAcquisitionFoodUsdaFoods[i] = o.R.FDCIDOfAcquisitionFoodUsdaFoods[ln-1]
			}
			o.R.FDCIDOfAcquisitionFoodUsdaFoods = o.R.FDCIDOfAcquisitionFoodUsdaFoods[:ln-1]
			break
		}
	}

	return nil
}

func removeFDCIDOfAcquisitionFoodUsdaFoodsFromFDCIDOfSampleFoodUsdaFoodsSlice(o *UsdaFood, related []*UsdaFood) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.FDCIDOfSampleFoodUsdaFoods {
			if o.FDCID != ri.FDCID {
				continue
			}

			ln := len(rel.R.FDCIDOfSampleFoodUsdaFoods)
			if ln > 1 && i < ln-1 {
				rel.R.FDCIDOfSampleFoodUsdaFoods[i] = rel.R.FDCIDOfSampleFoodUsdaFoods[ln-1]
			}
			rel.R.FDCIDOfSampleFoodUsdaFoods = rel.R.FDCIDOfSampleFoodUsdaFoods[:ln-1]
			break
		}
	}
}

// AddFDCUsdaFoodAttributes adds the given related objects to the existing relationships
// of the usda_food, optionally inserting them as new records.
// Appends related to o.R.FDCUsdaFoodAttributes.
// Sets related.R.FDC appropriately.
func (o *UsdaFood) AddFDCUsdaFoodAttributes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFoodAttribute) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.FDCID, o.FDCID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"usda_food_attribute\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
				strmangle.WhereClause("\"", "\"", 2, usdaFoodAttributePrimaryKeyColumns),
			)
			values := []interface{}{o.FDCID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.FDCID, o.FDCID)
		}
	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaFoodAttributes: related,
		}
	} else {
		o.R.FDCUsdaFoodAttributes = append(o.R.FDCUsdaFoodAttributes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &usdaFoodAttributeR{
				FDC: o,
			}
		} else {
			rel.R.FDC = o
		}
	}
	return nil
}

// SetFDCUsdaFoodAttributes removes all previously related items of the
// usda_food replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.FDC's FDCUsdaFoodAttributes accordingly.
// Replaces o.R.FDCUsdaFoodAttributes with related.
// Sets related.R.FDC's FDCUsdaFoodAttributes accordingly.
func (o *UsdaFood) SetFDCUsdaFoodAttributes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFoodAttribute) error {
	query := "update \"usda_food_attribute\" set \"fdc_id\" = null where \"fdc_id\" = $1"
	values := []interface{}{o.FDCID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.FDCUsdaFoodAttributes {
			queries.SetScanner(&rel.FDCID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.FDC = nil
		}

		o.R.FDCUsdaFoodAttributes = nil
	}
	return o.AddFDCUsdaFoodAttributes(ctx, exec, insert, related...)
}

// RemoveFDCUsdaFoodAttributes relationships from objects passed in.
// Removes related items from R.FDCUsdaFoodAttributes (uses pointer comparison, removal does not keep order)
// Sets related.R.FDC.
func (o *UsdaFood) RemoveFDCUsdaFoodAttributes(ctx context.Context, exec boil.ContextExecutor, related ...*UsdaFoodAttribute) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.FDCID, nil)
		if rel.R != nil {
			rel.R.FDC = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("fdc_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FDCUsdaFoodAttributes {
			if rel != ri {
				continue
			}

			ln := len(o.R.FDCUsdaFoodAttributes)
			if ln > 1 && i < ln-1 {
				o.R.FDCUsdaFoodAttributes[i] = o.R.FDCUsdaFoodAttributes[ln-1]
			}
			o.R.FDCUsdaFoodAttributes = o.R.FDCUsdaFoodAttributes[:ln-1]
			break
		}
	}

	return nil
}

// AddFDCUsdaFoodComponents adds the given related objects to the existing relationships
// of the usda_food, optionally inserting them as new records.
// Appends related to o.R.FDCUsdaFoodComponents.
// Sets related.R.FDC appropriately.
func (o *UsdaFood) AddFDCUsdaFoodComponents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFoodComponent) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.FDCID, o.FDCID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"usda_food_component\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
				strmangle.WhereClause("\"", "\"", 2, usdaFoodComponentPrimaryKeyColumns),
			)
			values := []interface{}{o.FDCID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.FDCID, o.FDCID)
		}
	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaFoodComponents: related,
		}
	} else {
		o.R.FDCUsdaFoodComponents = append(o.R.FDCUsdaFoodComponents, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &usdaFoodComponentR{
				FDC: o,
			}
		} else {
			rel.R.FDC = o
		}
	}
	return nil
}

// SetFDCUsdaFoodComponents removes all previously related items of the
// usda_food replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.FDC's FDCUsdaFoodComponents accordingly.
// Replaces o.R.FDCUsdaFoodComponents with related.
// Sets related.R.FDC's FDCUsdaFoodComponents accordingly.
func (o *UsdaFood) SetFDCUsdaFoodComponents(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFoodComponent) error {
	query := "update \"usda_food_component\" set \"fdc_id\" = null where \"fdc_id\" = $1"
	values := []interface{}{o.FDCID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.FDCUsdaFoodComponents {
			queries.SetScanner(&rel.FDCID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.FDC = nil
		}

		o.R.FDCUsdaFoodComponents = nil
	}
	return o.AddFDCUsdaFoodComponents(ctx, exec, insert, related...)
}

// RemoveFDCUsdaFoodComponents relationships from objects passed in.
// Removes related items from R.FDCUsdaFoodComponents (uses pointer comparison, removal does not keep order)
// Sets related.R.FDC.
func (o *UsdaFood) RemoveFDCUsdaFoodComponents(ctx context.Context, exec boil.ContextExecutor, related ...*UsdaFoodComponent) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.FDCID, nil)
		if rel.R != nil {
			rel.R.FDC = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("fdc_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FDCUsdaFoodComponents {
			if rel != ri {
				continue
			}

			ln := len(o.R.FDCUsdaFoodComponents)
			if ln > 1 && i < ln-1 {
				o.R.FDCUsdaFoodComponents[i] = o.R.FDCUsdaFoodComponents[ln-1]
			}
			o.R.FDCUsdaFoodComponents = o.R.FDCUsdaFoodComponents[:ln-1]
			break
		}
	}

	return nil
}

// AddFDCUsdaFoodNutrientConversionFactors adds the given related objects to the existing relationships
// of the usda_food, optionally inserting them as new records.
// Appends related to o.R.FDCUsdaFoodNutrientConversionFactors.
// Sets related.R.FDC appropriately.
func (o *UsdaFood) AddFDCUsdaFoodNutrientConversionFactors(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFoodNutrientConversionFactor) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.FDCID, o.FDCID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"usda_food_nutrient_conversion_factor\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
				strmangle.WhereClause("\"", "\"", 2, usdaFoodNutrientConversionFactorPrimaryKeyColumns),
			)
			values := []interface{}{o.FDCID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.FDCID, o.FDCID)
		}
	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaFoodNutrientConversionFactors: related,
		}
	} else {
		o.R.FDCUsdaFoodNutrientConversionFactors = append(o.R.FDCUsdaFoodNutrientConversionFactors, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &usdaFoodNutrientConversionFactorR{
				FDC: o,
			}
		} else {
			rel.R.FDC = o
		}
	}
	return nil
}

// SetFDCUsdaFoodNutrientConversionFactors removes all previously related items of the
// usda_food replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.FDC's FDCUsdaFoodNutrientConversionFactors accordingly.
// Replaces o.R.FDCUsdaFoodNutrientConversionFactors with related.
// Sets related.R.FDC's FDCUsdaFoodNutrientConversionFactors accordingly.
func (o *UsdaFood) SetFDCUsdaFoodNutrientConversionFactors(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFoodNutrientConversionFactor) error {
	query := "update \"usda_food_nutrient_conversion_factor\" set \"fdc_id\" = null where \"fdc_id\" = $1"
	values := []interface{}{o.FDCID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.FDCUsdaFoodNutrientConversionFactors {
			queries.SetScanner(&rel.FDCID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.FDC = nil
		}

		o.R.FDCUsdaFoodNutrientConversionFactors = nil
	}
	return o.AddFDCUsdaFoodNutrientConversionFactors(ctx, exec, insert, related...)
}

// RemoveFDCUsdaFoodNutrientConversionFactors relationships from objects passed in.
// Removes related items from R.FDCUsdaFoodNutrientConversionFactors (uses pointer comparison, removal does not keep order)
// Sets related.R.FDC.
func (o *UsdaFood) RemoveFDCUsdaFoodNutrientConversionFactors(ctx context.Context, exec boil.ContextExecutor, related ...*UsdaFoodNutrientConversionFactor) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.FDCID, nil)
		if rel.R != nil {
			rel.R.FDC = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("fdc_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FDCUsdaFoodNutrientConversionFactors {
			if rel != ri {
				continue
			}

			ln := len(o.R.FDCUsdaFoodNutrientConversionFactors)
			if ln > 1 && i < ln-1 {
				o.R.FDCUsdaFoodNutrientConversionFactors[i] = o.R.FDCUsdaFoodNutrientConversionFactors[ln-1]
			}
			o.R.FDCUsdaFoodNutrientConversionFactors = o.R.FDCUsdaFoodNutrientConversionFactors[:ln-1]
			break
		}
	}

	return nil
}

// AddFDCUsdaFoodPortions adds the given related objects to the existing relationships
// of the usda_food, optionally inserting them as new records.
// Appends related to o.R.FDCUsdaFoodPortions.
// Sets related.R.FDC appropriately.
func (o *UsdaFood) AddFDCUsdaFoodPortions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFoodPortion) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.FDCID, o.FDCID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"usda_food_portion\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
				strmangle.WhereClause("\"", "\"", 2, usdaFoodPortionPrimaryKeyColumns),
			)
			values := []interface{}{o.FDCID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.FDCID, o.FDCID)
		}
	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaFoodPortions: related,
		}
	} else {
		o.R.FDCUsdaFoodPortions = append(o.R.FDCUsdaFoodPortions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &usdaFoodPortionR{
				FDC: o,
			}
		} else {
			rel.R.FDC = o
		}
	}
	return nil
}

// SetFDCUsdaFoodPortions removes all previously related items of the
// usda_food replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.FDC's FDCUsdaFoodPortions accordingly.
// Replaces o.R.FDCUsdaFoodPortions with related.
// Sets related.R.FDC's FDCUsdaFoodPortions accordingly.
func (o *UsdaFood) SetFDCUsdaFoodPortions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaFoodPortion) error {
	query := "update \"usda_food_portion\" set \"fdc_id\" = null where \"fdc_id\" = $1"
	values := []interface{}{o.FDCID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.FDCUsdaFoodPortions {
			queries.SetScanner(&rel.FDCID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.FDC = nil
		}

		o.R.FDCUsdaFoodPortions = nil
	}
	return o.AddFDCUsdaFoodPortions(ctx, exec, insert, related...)
}

// RemoveFDCUsdaFoodPortions relationships from objects passed in.
// Removes related items from R.FDCUsdaFoodPortions (uses pointer comparison, removal does not keep order)
// Sets related.R.FDC.
func (o *UsdaFood) RemoveFDCUsdaFoodPortions(ctx context.Context, exec boil.ContextExecutor, related ...*UsdaFoodPortion) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.FDCID, nil)
		if rel.R != nil {
			rel.R.FDC = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("fdc_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FDCUsdaFoodPortions {
			if rel != ri {
				continue
			}

			ln := len(o.R.FDCUsdaFoodPortions)
			if ln > 1 && i < ln-1 {
				o.R.FDCUsdaFoodPortions[i] = o.R.FDCUsdaFoodPortions[ln-1]
			}
			o.R.FDCUsdaFoodPortions = o.R.FDCUsdaFoodPortions[:ln-1]
			break
		}
	}

	return nil
}

// AddFDCUsdaInputFoods adds the given related objects to the existing relationships
// of the usda_food, optionally inserting them as new records.
// Appends related to o.R.FDCUsdaInputFoods.
// Sets related.R.FDC appropriately.
func (o *UsdaFood) AddFDCUsdaInputFoods(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaInputFood) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.FDCID, o.FDCID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"usda_input_food\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id"}),
				strmangle.WhereClause("\"", "\"", 2, usdaInputFoodPrimaryKeyColumns),
			)
			values := []interface{}{o.FDCID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.FDCID, o.FDCID)
		}
	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCUsdaInputFoods: related,
		}
	} else {
		o.R.FDCUsdaInputFoods = append(o.R.FDCUsdaInputFoods, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &usdaInputFoodR{
				FDC: o,
			}
		} else {
			rel.R.FDC = o
		}
	}
	return nil
}

// SetFDCUsdaInputFoods removes all previously related items of the
// usda_food replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.FDC's FDCUsdaInputFoods accordingly.
// Replaces o.R.FDCUsdaInputFoods with related.
// Sets related.R.FDC's FDCUsdaInputFoods accordingly.
func (o *UsdaFood) SetFDCUsdaInputFoods(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaInputFood) error {
	query := "update \"usda_input_food\" set \"fdc_id\" = null where \"fdc_id\" = $1"
	values := []interface{}{o.FDCID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.FDCUsdaInputFoods {
			queries.SetScanner(&rel.FDCID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.FDC = nil
		}

		o.R.FDCUsdaInputFoods = nil
	}
	return o.AddFDCUsdaInputFoods(ctx, exec, insert, related...)
}

// RemoveFDCUsdaInputFoods relationships from objects passed in.
// Removes related items from R.FDCUsdaInputFoods (uses pointer comparison, removal does not keep order)
// Sets related.R.FDC.
func (o *UsdaFood) RemoveFDCUsdaInputFoods(ctx context.Context, exec boil.ContextExecutor, related ...*UsdaInputFood) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.FDCID, nil)
		if rel.R != nil {
			rel.R.FDC = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("fdc_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FDCUsdaInputFoods {
			if rel != ri {
				continue
			}

			ln := len(o.R.FDCUsdaInputFoods)
			if ln > 1 && i < ln-1 {
				o.R.FDCUsdaInputFoods[i] = o.R.FDCUsdaInputFoods[ln-1]
			}
			o.R.FDCUsdaInputFoods = o.R.FDCUsdaInputFoods[:ln-1]
			break
		}
	}

	return nil
}

// AddFDCIDOfInputFoodUsdaInputFoods adds the given related objects to the existing relationships
// of the usda_food, optionally inserting them as new records.
// Appends related to o.R.FDCIDOfInputFoodUsdaInputFoods.
// Sets related.R.FDCIDOfInputFoodUsdaFood appropriately.
func (o *UsdaFood) AddFDCIDOfInputFoodUsdaInputFoods(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaInputFood) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.FDCIDOfInputFood, o.FDCID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"usda_input_food\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id_of_input_food"}),
				strmangle.WhereClause("\"", "\"", 2, usdaInputFoodPrimaryKeyColumns),
			)
			values := []interface{}{o.FDCID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.FDCIDOfInputFood, o.FDCID)
		}
	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCIDOfInputFoodUsdaInputFoods: related,
		}
	} else {
		o.R.FDCIDOfInputFoodUsdaInputFoods = append(o.R.FDCIDOfInputFoodUsdaInputFoods, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &usdaInputFoodR{
				FDCIDOfInputFoodUsdaFood: o,
			}
		} else {
			rel.R.FDCIDOfInputFoodUsdaFood = o
		}
	}
	return nil
}

// SetFDCIDOfInputFoodUsdaInputFoods removes all previously related items of the
// usda_food replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.FDCIDOfInputFoodUsdaFood's FDCIDOfInputFoodUsdaInputFoods accordingly.
// Replaces o.R.FDCIDOfInputFoodUsdaInputFoods with related.
// Sets related.R.FDCIDOfInputFoodUsdaFood's FDCIDOfInputFoodUsdaInputFoods accordingly.
func (o *UsdaFood) SetFDCIDOfInputFoodUsdaInputFoods(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaInputFood) error {
	query := "update \"usda_input_food\" set \"fdc_id_of_input_food\" = null where \"fdc_id_of_input_food\" = $1"
	values := []interface{}{o.FDCID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.FDCIDOfInputFoodUsdaInputFoods {
			queries.SetScanner(&rel.FDCIDOfInputFood, nil)
			if rel.R == nil {
				continue
			}

			rel.R.FDCIDOfInputFoodUsdaFood = nil
		}

		o.R.FDCIDOfInputFoodUsdaInputFoods = nil
	}
	return o.AddFDCIDOfInputFoodUsdaInputFoods(ctx, exec, insert, related...)
}

// RemoveFDCIDOfInputFoodUsdaInputFoods relationships from objects passed in.
// Removes related items from R.FDCIDOfInputFoodUsdaInputFoods (uses pointer comparison, removal does not keep order)
// Sets related.R.FDCIDOfInputFoodUsdaFood.
func (o *UsdaFood) RemoveFDCIDOfInputFoodUsdaInputFoods(ctx context.Context, exec boil.ContextExecutor, related ...*UsdaInputFood) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.FDCIDOfInputFood, nil)
		if rel.R != nil {
			rel.R.FDCIDOfInputFoodUsdaFood = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("fdc_id_of_input_food")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FDCIDOfInputFoodUsdaInputFoods {
			if rel != ri {
				continue
			}

			ln := len(o.R.FDCIDOfInputFoodUsdaInputFoods)
			if ln > 1 && i < ln-1 {
				o.R.FDCIDOfInputFoodUsdaInputFoods[i] = o.R.FDCIDOfInputFoodUsdaInputFoods[ln-1]
			}
			o.R.FDCIDOfInputFoodUsdaInputFoods = o.R.FDCIDOfInputFoodUsdaInputFoods[:ln-1]
			break
		}
	}

	return nil
}

// AddFDCIDOfSampleFoodUsdaSubSampleFoods adds the given related objects to the existing relationships
// of the usda_food, optionally inserting them as new records.
// Appends related to o.R.FDCIDOfSampleFoodUsdaSubSampleFoods.
// Sets related.R.FDCIDOfSampleFoodUsdaFood appropriately.
func (o *UsdaFood) AddFDCIDOfSampleFoodUsdaSubSampleFoods(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaSubSampleFood) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.FDCIDOfSampleFood, o.FDCID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"usda_sub_sample_food\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"fdc_id_of_sample_food"}),
				strmangle.WhereClause("\"", "\"", 2, usdaSubSampleFoodPrimaryKeyColumns),
			)
			values := []interface{}{o.FDCID, rel.FDCID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.FDCIDOfSampleFood, o.FDCID)
		}
	}

	if o.R == nil {
		o.R = &usdaFoodR{
			FDCIDOfSampleFoodUsdaSubSampleFoods: related,
		}
	} else {
		o.R.FDCIDOfSampleFoodUsdaSubSampleFoods = append(o.R.FDCIDOfSampleFoodUsdaSubSampleFoods, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &usdaSubSampleFoodR{
				FDCIDOfSampleFoodUsdaFood: o,
			}
		} else {
			rel.R.FDCIDOfSampleFoodUsdaFood = o
		}
	}
	return nil
}

// SetFDCIDOfSampleFoodUsdaSubSampleFoods removes all previously related items of the
// usda_food replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.FDCIDOfSampleFoodUsdaFood's FDCIDOfSampleFoodUsdaSubSampleFoods accordingly.
// Replaces o.R.FDCIDOfSampleFoodUsdaSubSampleFoods with related.
// Sets related.R.FDCIDOfSampleFoodUsdaFood's FDCIDOfSampleFoodUsdaSubSampleFoods accordingly.
func (o *UsdaFood) SetFDCIDOfSampleFoodUsdaSubSampleFoods(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UsdaSubSampleFood) error {
	query := "update \"usda_sub_sample_food\" set \"fdc_id_of_sample_food\" = null where \"fdc_id_of_sample_food\" = $1"
	values := []interface{}{o.FDCID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.FDCIDOfSampleFoodUsdaSubSampleFoods {
			queries.SetScanner(&rel.FDCIDOfSampleFood, nil)
			if rel.R == nil {
				continue
			}

			rel.R.FDCIDOfSampleFoodUsdaFood = nil
		}

		o.R.FDCIDOfSampleFoodUsdaSubSampleFoods = nil
	}
	return o.AddFDCIDOfSampleFoodUsdaSubSampleFoods(ctx, exec, insert, related...)
}

// RemoveFDCIDOfSampleFoodUsdaSubSampleFoods relationships from objects passed in.
// Removes related items from R.FDCIDOfSampleFoodUsdaSubSampleFoods (uses pointer comparison, removal does not keep order)
// Sets related.R.FDCIDOfSampleFoodUsdaFood.
func (o *UsdaFood) RemoveFDCIDOfSampleFoodUsdaSubSampleFoods(ctx context.Context, exec boil.ContextExecutor, related ...*UsdaSubSampleFood) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.FDCIDOfSampleFood, nil)
		if rel.R != nil {
			rel.R.FDCIDOfSampleFoodUsdaFood = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("fdc_id_of_sample_food")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.FDCIDOfSampleFoodUsdaSubSampleFoods {
			if rel != ri {
				continue
			}

			ln := len(o.R.FDCIDOfSampleFoodUsdaSubSampleFoods)
			if ln > 1 && i < ln-1 {
				o.R.FDCIDOfSampleFoodUsdaSubSampleFoods[i] = o.R.FDCIDOfSampleFoodUsdaSubSampleFoods[ln-1]
			}
			o.R.FDCIDOfSampleFoodUsdaSubSampleFoods = o.R.FDCIDOfSampleFoodUsdaSubSampleFoods[:ln-1]
			break
		}
	}

	return nil
}

// UsdaFoods retrieves all the records using an executor.
func UsdaFoods(mods ...qm.QueryMod) usdaFoodQuery {
	mods = append(mods, qm.From("\"usda_food\""))
	return usdaFoodQuery{NewQuery(mods...)}
}

// FindUsdaFood retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUsdaFood(ctx context.Context, exec boil.ContextExecutor, fDCID int, selectCols ...string) (*UsdaFood, error) {
	usdaFoodObj := &UsdaFood{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"usda_food\" where \"fdc_id\"=$1", sel,
	)

	q := queries.Raw(query, fDCID)

	err := q.Bind(ctx, exec, usdaFoodObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from usda_food")
	}

	if err = usdaFoodObj.doAfterSelectHooks(ctx, exec); err != nil {
		return usdaFoodObj, err
	}

	return usdaFoodObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *UsdaFood) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no usda_food provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(usdaFoodColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	usdaFoodInsertCacheMut.RLock()
	cache, cached := usdaFoodInsertCache[key]
	usdaFoodInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			usdaFoodAllColumns,
			usdaFoodColumnsWithDefault,
			usdaFoodColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(usdaFoodType, usdaFoodMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(usdaFoodType, usdaFoodMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"usda_food\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"usda_food\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into usda_food")
	}

	if !cached {
		usdaFoodInsertCacheMut.Lock()
		usdaFoodInsertCache[key] = cache
		usdaFoodInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the UsdaFood.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *UsdaFood) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	usdaFoodUpdateCacheMut.RLock()
	cache, cached := usdaFoodUpdateCache[key]
	usdaFoodUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			usdaFoodAllColumns,
			usdaFoodPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update usda_food, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"usda_food\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, usdaFoodPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(usdaFoodType, usdaFoodMapping, append(wl, usdaFoodPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update usda_food row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for usda_food")
	}

	if !cached {
		usdaFoodUpdateCacheMut.Lock()
		usdaFoodUpdateCache[key] = cache
		usdaFoodUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q usdaFoodQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for usda_food")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for usda_food")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UsdaFoodSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), usdaFoodPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"usda_food\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, usdaFoodPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in usdaFood slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all usdaFood")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *UsdaFood) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no usda_food provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(usdaFoodColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	usdaFoodUpsertCacheMut.RLock()
	cache, cached := usdaFoodUpsertCache[key]
	usdaFoodUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			usdaFoodAllColumns,
			usdaFoodColumnsWithDefault,
			usdaFoodColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			usdaFoodAllColumns,
			usdaFoodPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert usda_food, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(usdaFoodPrimaryKeyColumns))
			copy(conflict, usdaFoodPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"usda_food\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(usdaFoodType, usdaFoodMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(usdaFoodType, usdaFoodMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert usda_food")
	}

	if !cached {
		usdaFoodUpsertCacheMut.Lock()
		usdaFoodUpsertCache[key] = cache
		usdaFoodUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single UsdaFood record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *UsdaFood) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no UsdaFood provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), usdaFoodPrimaryKeyMapping)
	sql := "DELETE FROM \"usda_food\" WHERE \"fdc_id\"=$1"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from usda_food")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for usda_food")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q usdaFoodQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no usdaFoodQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from usda_food")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for usda_food")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UsdaFoodSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(usdaFoodBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), usdaFoodPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"usda_food\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, usdaFoodPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from usdaFood slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for usda_food")
	}

	if len(usdaFoodAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *UsdaFood) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindUsdaFood(ctx, exec, o.FDCID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UsdaFoodSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UsdaFoodSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), usdaFoodPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"usda_food\".* FROM \"usda_food\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, usdaFoodPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in UsdaFoodSlice")
	}

	*o = slice

	return nil
}

// UsdaFoodExists checks if the UsdaFood row exists.
func UsdaFoodExists(ctx context.Context, exec boil.ContextExecutor, fDCID int) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"usda_food\" where \"fdc_id\"=$1 limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, fDCID)
	}
	row := exec.QueryRowContext(ctx, sql, fDCID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if usda_food exists")
	}

	return exists, nil
}
