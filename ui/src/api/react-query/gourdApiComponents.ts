/**
 * Generated by @openapi-codegen
 *
 * @version 1.0.0
 */
import * as reactQuery from "@tanstack/react-query";
import { useGourdApiContext, GourdApiContext } from "./gourdApiContext";
import type * as Fetcher from "./gourdApiFetcher";
import { gourdApiFetch } from "./gourdApiFetcher";
import type * as Schemas from "./gourdApiSchemas";
import type { ClientErrorStatus, ServerErrorStatus } from "./gourdApiUtils";

export type AuthLoginQueryParams = {
  /**
   * Google code
   */
  code: string;
};

export type AuthLoginError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type AuthLoginVariables = {
  queryParams: AuthLoginQueryParams;
} & GourdApiContext["fetcherOptions"];

/**
 * Second step of https://developers.google.com/identity/sign-in/web/backend-auth#send-the-id-token-to-your-server
 */
export const fetchAuthLogin = (
  variables: AuthLoginVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.AuthResp,
    AuthLoginError,
    undefined,
    {},
    AuthLoginQueryParams,
    {}
  >({ url: "/auth", method: "post", ...variables, signal });

/**
 * Second step of https://developers.google.com/identity/sign-in/web/backend-auth#send-the-id-token-to-your-server
 */
export const useAuthLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AuthResp,
      AuthLoginError,
      AuthLoginVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useGourdApiContext();
  return reactQuery.useMutation<
    Schemas.AuthResp,
    AuthLoginError,
    AuthLoginVariables
  >(
    (variables: AuthLoginVariables) =>
      fetchAuthLogin({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetConfigError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type GetConfigVariables = GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchGetConfig = (
  variables: GetConfigVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<Schemas.ConfigData, GetConfigError, undefined, {}, {}, {}>({
    url: "/config",
    method: "get",
    ...variables,
    signal,
  });

/**
 * todo
 */
export const useGetConfig = <TData = Schemas.ConfigData>(
  variables: GetConfigVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ConfigData, GetConfigError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<Schemas.ConfigData, GetConfigError, TData>(
    queryKeyFn({ path: "/config", operationId: "getConfig", variables }),
    ({ signal }) => fetchGetConfig({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type DoSyncQueryParams = {
  /**
   * how many days to lookback
   */
  lookback_days: number;
};

export type DoSyncError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type DoSyncVariables = {
  queryParams: DoSyncQueryParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchDoSync = (variables: DoSyncVariables, signal?: AbortSignal) =>
  gourdApiFetch<
    Record<string, any>,
    DoSyncError,
    undefined,
    {},
    DoSyncQueryParams,
    {}
  >({ url: "/sync", method: "get", ...variables, signal });

/**
 * todo
 */
export const useDoSync = <TData = Record<string, any>>(
  variables: DoSyncVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Record<string, any>, DoSyncError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<Record<string, any>, DoSyncError, TData>(
    queryKeyFn({ path: "/sync", operationId: "doSync", variables }),
    ({ signal }) => fetchDoSync({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type ListPhotosQueryParams = {
  /**
   * The number of items to skip before starting to collect the result set.
   *
   * @minimum 0
   */
  offset?: number;
  /**
   * The numbers of items to return.
   *
   * @minimum 1
   * @maximum 50
   * @default 20
   */
  limit?: number;
};

export type ListPhotosError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type ListPhotosVariables = {
  queryParams?: ListPhotosQueryParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchListPhotos = (
  variables: ListPhotosVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.PaginatedPhotos,
    ListPhotosError,
    undefined,
    {},
    ListPhotosQueryParams,
    {}
  >({ url: "/photos", method: "get", ...variables, signal });

/**
 * todo
 */
export const useListPhotos = <TData = Schemas.PaginatedPhotos>(
  variables: ListPhotosVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.PaginatedPhotos, ListPhotosError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<Schemas.PaginatedPhotos, ListPhotosError, TData>(
    queryKeyFn({ path: "/photos", operationId: "listPhotos", variables }),
    ({ signal }) =>
      fetchListPhotos({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type ListAllAlbumsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type ListAllAlbumsResponse = {
  /**
   * The list of albums
   */
  albums?: Schemas.GooglePhotosAlbum[];
};

export type ListAllAlbumsVariables = GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchListAllAlbums = (
  variables: ListAllAlbumsVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    ListAllAlbumsResponse,
    ListAllAlbumsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/albums", method: "get", ...variables, signal });

/**
 * todo
 */
export const useListAllAlbums = <TData = ListAllAlbumsResponse>(
  variables: ListAllAlbumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      ListAllAlbumsResponse,
      ListAllAlbumsError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<ListAllAlbumsResponse, ListAllAlbumsError, TData>(
    queryKeyFn({ path: "/albums", operationId: "listAllAlbums", variables }),
    ({ signal }) =>
      fetchListAllAlbums({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type SearchQueryParams = {
  /**
   * The number of items to skip before starting to collect the result set.
   *
   * @minimum 0
   */
  offset?: number;
  /**
   * The numbers of items to return.
   *
   * @minimum 1
   * @maximum 50
   * @default 20
   */
  limit?: number;
  /**
   * The search query (name).
   */
  name: string;
};

export type SearchError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type SearchVariables = {
  queryParams: SearchQueryParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchSearch = (variables: SearchVariables, signal?: AbortSignal) =>
  gourdApiFetch<
    Schemas.SearchResult,
    SearchError,
    undefined,
    {},
    SearchQueryParams,
    {}
  >({ url: "/search", method: "get", ...variables, signal });

/**
 * todo
 */
export const useSearch = <TData = Schemas.SearchResult>(
  variables: SearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.SearchResult, SearchError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<Schemas.SearchResult, SearchError, TData>(
    queryKeyFn({ path: "/search", operationId: "search", variables }),
    ({ signal }) => fetchSearch({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type ListMealsQueryParams = {
  /**
   * The number of items to skip before starting to collect the result set.
   *
   * @minimum 0
   */
  offset?: number;
  /**
   * The numbers of items to return.
   *
   * @minimum 1
   * @maximum 50
   * @default 20
   */
  limit?: number;
};

export type ListMealsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type ListMealsVariables = {
  queryParams?: ListMealsQueryParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchListMeals = (
  variables: ListMealsVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.PaginatedMeals,
    ListMealsError,
    undefined,
    {},
    ListMealsQueryParams,
    {}
  >({ url: "/meals", method: "get", ...variables, signal });

/**
 * todo
 */
export const useListMeals = <TData = Schemas.PaginatedMeals>(
  variables: ListMealsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.PaginatedMeals, ListMealsError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<Schemas.PaginatedMeals, ListMealsError, TData>(
    queryKeyFn({ path: "/meals", operationId: "listMeals", variables }),
    ({ signal }) => fetchListMeals({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetMealByIdPathParams = {
  /**
   * The id of the meal to retrieve
   */
  mealId: string;
};

export type GetMealByIdError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type GetMealByIdVariables = {
  pathParams: GetMealByIdPathParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchGetMealById = (
  variables: GetMealByIdVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.Meal,
    GetMealByIdError,
    undefined,
    {},
    {},
    GetMealByIdPathParams
  >({ url: "/meals/{mealId}", method: "get", ...variables, signal });

/**
 * todo
 */
export const useGetMealById = <TData = Schemas.Meal>(
  variables: GetMealByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Meal, GetMealByIdError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<Schemas.Meal, GetMealByIdError, TData>(
    queryKeyFn({
      path: "/meals/{meal_id}",
      operationId: "getMealById",
      variables,
    }),
    ({ signal }) =>
      fetchGetMealById({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type UpdateRecipesForMealPathParams = {
  /**
   * The id of the meal to retrieve
   */
  mealId: string;
};

export type UpdateRecipesForMealError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type UpdateRecipesForMealVariables = {
  body: Schemas.MealRecipeUpdate;
  pathParams: UpdateRecipesForMealPathParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchUpdateRecipesForMeal = (
  variables: UpdateRecipesForMealVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.Meal,
    UpdateRecipesForMealError,
    Schemas.MealRecipeUpdate,
    {},
    {},
    UpdateRecipesForMealPathParams
  >({ url: "/meals/{mealId}/recipes", method: "patch", ...variables, signal });

/**
 * todo
 */
export const useUpdateRecipesForMeal = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Meal,
      UpdateRecipesForMealError,
      UpdateRecipesForMealVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useGourdApiContext();
  return reactQuery.useMutation<
    Schemas.Meal,
    UpdateRecipesForMealError,
    UpdateRecipesForMealVariables
  >(
    (variables: UpdateRecipesForMealVariables) =>
      fetchUpdateRecipesForMeal({ ...fetcherOptions, ...variables }),
    options
  );
};

export type ListIngredientsQueryParams = {
  /**
   * The number of items to skip before starting to collect the result set.
   *
   * @minimum 0
   */
  offset?: number;
  /**
   * The numbers of items to return.
   *
   * @minimum 1
   * @maximum 50
   * @default 20
   */
  limit?: number;
  /**
   * ids
   */
  ingredient_id?: string[];
};

export type ListIngredientsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type ListIngredientsVariables = {
  queryParams?: ListIngredientsQueryParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchListIngredients = (
  variables: ListIngredientsVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.PaginatedIngredients,
    ListIngredientsError,
    undefined,
    {},
    ListIngredientsQueryParams,
    {}
  >({ url: "/ingredients", method: "get", ...variables, signal });

/**
 * todo
 */
export const useListIngredients = <TData = Schemas.PaginatedIngredients>(
  variables: ListIngredientsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PaginatedIngredients,
      ListIngredientsError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<
    Schemas.PaginatedIngredients,
    ListIngredientsError,
    TData
  >(
    queryKeyFn({
      path: "/ingredients",
      operationId: "listIngredients",
      variables,
    }),
    ({ signal }) =>
      fetchListIngredients({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type CreateIngredientsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: Schemas.Error;
}>;

export type CreateIngredientsVariables = {
  body: Schemas.Ingredient;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchCreateIngredients = (
  variables: CreateIngredientsVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.Ingredient,
    CreateIngredientsError,
    Schemas.Ingredient,
    {},
    {},
    {}
  >({ url: "/ingredients", method: "post", ...variables, signal });

/**
 * todo
 */
export const useCreateIngredients = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Ingredient,
      CreateIngredientsError,
      CreateIngredientsVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useGourdApiContext();
  return reactQuery.useMutation<
    Schemas.Ingredient,
    CreateIngredientsError,
    CreateIngredientsVariables
  >(
    (variables: CreateIngredientsVariables) =>
      fetchCreateIngredients({ ...fetcherOptions, ...variables }),
    options
  );
};

export type LoadIngredientMappingsError = Fetcher.ErrorWrapper<undefined>;

export type LoadIngredientMappingsVariables = {
  body: Schemas.IngredientMappingsPayload;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchLoadIngredientMappings = (
  variables: LoadIngredientMappingsVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Record<string, any>,
    LoadIngredientMappingsError,
    Schemas.IngredientMappingsPayload,
    {},
    {},
    {}
  >({
    url: "/meta/load_ingredient_mappings",
    method: "post",
    ...variables,
    signal,
  });

/**
 * todo
 */
export const useLoadIngredientMappings = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Record<string, any>,
      LoadIngredientMappingsError,
      LoadIngredientMappingsVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useGourdApiContext();
  return reactQuery.useMutation<
    Record<string, any>,
    LoadIngredientMappingsError,
    LoadIngredientMappingsVariables
  >(
    (variables: LoadIngredientMappingsVariables) =>
      fetchLoadIngredientMappings({ ...fetcherOptions, ...variables }),
    options
  );
};

export type ListRecipesQueryParams = {
  /**
   * The number of items to skip before starting to collect the result set.
   *
   * @minimum 0
   */
  offset?: number;
  /**
   * The numbers of items to return.
   *
   * @minimum 1
   * @maximum 50
   * @default 20
   */
  limit?: number;
};

export type ListRecipesError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type ListRecipesVariables = {
  queryParams?: ListRecipesQueryParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchListRecipes = (
  variables: ListRecipesVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.PaginatedRecipeWrappers,
    ListRecipesError,
    undefined,
    {},
    ListRecipesQueryParams,
    {}
  >({ url: "/recipes", method: "get", ...variables, signal });

/**
 * todo
 */
export const useListRecipes = <TData = Schemas.PaginatedRecipeWrappers>(
  variables: ListRecipesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PaginatedRecipeWrappers,
      ListRecipesError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<
    Schemas.PaginatedRecipeWrappers,
    ListRecipesError,
    TData
  >(
    queryKeyFn({ path: "/recipes", operationId: "listRecipes", variables }),
    ({ signal }) =>
      fetchListRecipes({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type CreateRecipesError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: Schemas.Error;
}>;

export type CreateRecipesVariables = {
  body: Schemas.RecipeWrapperInput;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchCreateRecipes = (
  variables: CreateRecipesVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.RecipeWrapper,
    CreateRecipesError,
    Schemas.RecipeWrapperInput,
    {},
    {},
    {}
  >({ url: "/recipes", method: "post", ...variables, signal });

/**
 * todo
 */
export const useCreateRecipes = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RecipeWrapper,
      CreateRecipesError,
      CreateRecipesVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useGourdApiContext();
  return reactQuery.useMutation<
    Schemas.RecipeWrapper,
    CreateRecipesError,
    CreateRecipesVariables
  >(
    (variables: CreateRecipesVariables) =>
      fetchCreateRecipes({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetLatexByRecipeIdPathParams = {
  /**
   * The id of the recipe to retrieve
   */
  recipeId: string;
};

export type GetLatexByRecipeIdError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type GetLatexByRecipeIdVariables = {
  pathParams: GetLatexByRecipeIdPathParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchGetLatexByRecipeId = (
  variables: GetLatexByRecipeIdVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    undefined,
    GetLatexByRecipeIdError,
    undefined,
    {},
    {},
    GetLatexByRecipeIdPathParams
  >({ url: "/recipes/{recipeId}/latex", method: "get", ...variables, signal });

/**
 * todo
 */
export const useGetLatexByRecipeId = <TData = undefined>(
  variables: GetLatexByRecipeIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetLatexByRecipeIdError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<undefined, GetLatexByRecipeIdError, TData>(
    queryKeyFn({
      path: "/recipes/{recipe_id}/latex",
      operationId: "getLatexByRecipeId",
      variables,
    }),
    ({ signal }) =>
      fetchGetLatexByRecipeId({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetRecipeByIdPathParams = {
  /**
   * The id of the recipe to retrieve
   */
  recipeId: string;
};

export type GetRecipeByIdError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type GetRecipeByIdVariables = {
  pathParams: GetRecipeByIdPathParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchGetRecipeById = (
  variables: GetRecipeByIdVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.RecipeWrapper,
    GetRecipeByIdError,
    undefined,
    {},
    {},
    GetRecipeByIdPathParams
  >({ url: "/recipes/{recipeId}", method: "get", ...variables, signal });

/**
 * todo
 */
export const useGetRecipeById = <TData = Schemas.RecipeWrapper>(
  variables: GetRecipeByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RecipeWrapper,
      GetRecipeByIdError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<Schemas.RecipeWrapper, GetRecipeByIdError, TData>(
    queryKeyFn({
      path: "/recipes/{recipe_id}",
      operationId: "getRecipeById",
      variables,
    }),
    ({ signal }) =>
      fetchGetRecipeById({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetRecipesByIdsQueryParams = {
  /**
   * detail ids
   */
  recipe_id: string[];
};

export type GetRecipesByIdsError = Fetcher.ErrorWrapper<undefined>;

export type GetRecipesByIdsVariables = {
  queryParams: GetRecipesByIdsQueryParams;
} & GourdApiContext["fetcherOptions"];

/**
 * get recipes by ids
 */
export const fetchGetRecipesByIds = (
  variables: GetRecipesByIdsVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.PaginatedRecipeWrappers,
    GetRecipesByIdsError,
    undefined,
    {},
    GetRecipesByIdsQueryParams,
    {}
  >({ url: "/recipes/bulk", method: "get", ...variables, signal });

/**
 * get recipes by ids
 */
export const useGetRecipesByIds = <TData = Schemas.PaginatedRecipeWrappers>(
  variables: GetRecipesByIdsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PaginatedRecipeWrappers,
      GetRecipesByIdsError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<
    Schemas.PaginatedRecipeWrappers,
    GetRecipesByIdsError,
    TData
  >(
    queryKeyFn({
      path: "/recipes/bulk",
      operationId: "getRecipesByIds",
      variables,
    }),
    ({ signal }) =>
      fetchGetRecipesByIds({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type SumRecipesError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type SumRecipesRequestBody = {
  inputs: Schemas.EntitySummary[];
};

export type SumRecipesVariables = {
  body: SumRecipesRequestBody;
} & GourdApiContext["fetcherOptions"];

/**
 * sums up the given recipes
 */
export const fetchSumRecipes = (
  variables: SumRecipesVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.SumsResponse,
    SumRecipesError,
    SumRecipesRequestBody,
    {},
    {},
    {}
  >({ url: "/recipes/sum", method: "post", ...variables, signal });

/**
 * sums up the given recipes
 */
export const useSumRecipes = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SumsResponse,
      SumRecipesError,
      SumRecipesVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useGourdApiContext();
  return reactQuery.useMutation<
    Schemas.SumsResponse,
    SumRecipesError,
    SumRecipesVariables
  >(
    (variables: SumRecipesVariables) =>
      fetchSumRecipes({ ...fetcherOptions, ...variables }),
    options
  );
};

export type ScrapeRecipeError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: Schemas.Error;
}>;

export type ScrapeRecipeRequestBody = {
  url: string;
};

export type ScrapeRecipeVariables = {
  body: ScrapeRecipeRequestBody;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchScrapeRecipe = (
  variables: ScrapeRecipeVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.RecipeWrapper,
    ScrapeRecipeError,
    ScrapeRecipeRequestBody,
    {},
    {},
    {}
  >({ url: "/recipes/scrape", method: "post", ...variables, signal });

/**
 * todo
 */
export const useScrapeRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RecipeWrapper,
      ScrapeRecipeError,
      ScrapeRecipeVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useGourdApiContext();
  return reactQuery.useMutation<
    Schemas.RecipeWrapper,
    ScrapeRecipeError,
    ScrapeRecipeVariables
  >(
    (variables: ScrapeRecipeVariables) =>
      fetchScrapeRecipe({ ...fetcherOptions, ...variables }),
    options
  );
};

export type ConvertIngredientToRecipePathParams = {
  /**
   * The id of the ingredient
   */
  ingredientId: string;
};

export type ConvertIngredientToRecipeError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: Schemas.Error;
}>;

export type ConvertIngredientToRecipeVariables = {
  pathParams: ConvertIngredientToRecipePathParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchConvertIngredientToRecipe = (
  variables: ConvertIngredientToRecipeVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.RecipeDetail,
    ConvertIngredientToRecipeError,
    undefined,
    {},
    {},
    ConvertIngredientToRecipePathParams
  >({
    url: "/ingredients/{ingredientId}/convert_to_recipe",
    method: "post",
    ...variables,
    signal,
  });

/**
 * todo
 */
export const useConvertIngredientToRecipe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RecipeDetail,
      ConvertIngredientToRecipeError,
      ConvertIngredientToRecipeVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useGourdApiContext();
  return reactQuery.useMutation<
    Schemas.RecipeDetail,
    ConvertIngredientToRecipeError,
    ConvertIngredientToRecipeVariables
  >(
    (variables: ConvertIngredientToRecipeVariables) =>
      fetchConvertIngredientToRecipe({ ...fetcherOptions, ...variables }),
    options
  );
};

export type AssociateFoodWithIngredientPathParams = {
  /**
   * The id of the ingredient
   */
  ingredientId: string;
};

export type AssociateFoodWithIngredientQueryParams = {
  /**
   * The FDC id of the food to link to the ingredient
   *
   * @minimum 1
   */
  fdc_id: number;
};

export type AssociateFoodWithIngredientError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: Schemas.Error;
}>;

export type AssociateFoodWithIngredientVariables = {
  pathParams: AssociateFoodWithIngredientPathParams;
  queryParams: AssociateFoodWithIngredientQueryParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchAssociateFoodWithIngredient = (
  variables: AssociateFoodWithIngredientVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.RecipeDetail,
    AssociateFoodWithIngredientError,
    undefined,
    {},
    AssociateFoodWithIngredientQueryParams,
    AssociateFoodWithIngredientPathParams
  >({
    url: "/ingredients/{ingredientId}/associate_food",
    method: "post",
    ...variables,
    signal,
  });

/**
 * todo
 */
export const useAssociateFoodWithIngredient = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RecipeDetail,
      AssociateFoodWithIngredientError,
      AssociateFoodWithIngredientVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useGourdApiContext();
  return reactQuery.useMutation<
    Schemas.RecipeDetail,
    AssociateFoodWithIngredientError,
    AssociateFoodWithIngredientVariables
  >(
    (variables: AssociateFoodWithIngredientVariables) =>
      fetchAssociateFoodWithIngredient({ ...fetcherOptions, ...variables }),
    options
  );
};

export type MergeIngredientsPathParams = {
  /**
   * The id of the ingredient to merge into
   */
  ingredientId: string;
};

export type MergeIngredientsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 201>;
  payload: Schemas.Error;
}>;

export type MergeIngredientsRequestBody = {
  /**
   * @minItems 1
   * @maxItems 50
   */
  ingredient_ids: string[];
};

export type MergeIngredientsVariables = {
  body: MergeIngredientsRequestBody;
  pathParams: MergeIngredientsPathParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchMergeIngredients = (
  variables: MergeIngredientsVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.Ingredient,
    MergeIngredientsError,
    MergeIngredientsRequestBody,
    {},
    {},
    MergeIngredientsPathParams
  >({
    url: "/ingredients/{ingredientId}/merge",
    method: "post",
    ...variables,
    signal,
  });

/**
 * todo
 */
export const useMergeIngredients = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Ingredient,
      MergeIngredientsError,
      MergeIngredientsVariables
    >,
    "mutationFn"
  >
) => {
  const { fetcherOptions } = useGourdApiContext();
  return reactQuery.useMutation<
    Schemas.Ingredient,
    MergeIngredientsError,
    MergeIngredientsVariables
  >(
    (variables: MergeIngredientsVariables) =>
      fetchMergeIngredients({ ...fetcherOptions, ...variables }),
    options
  );
};

export type GetFoodByIdPathParams = {
  /**
   * The fdc id
   */
  fdcId: number;
};

export type GetFoodByIdError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type GetFoodByIdVariables = {
  pathParams: GetFoodByIdPathParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchGetFoodById = (
  variables: GetFoodByIdVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.TempFood,
    GetFoodByIdError,
    undefined,
    {},
    {},
    GetFoodByIdPathParams
  >({ url: "/foods/{fdcId}", method: "get", ...variables, signal });

/**
 * todo
 */
export const useGetFoodById = <TData = Schemas.TempFood>(
  variables: GetFoodByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.TempFood, GetFoodByIdError, TData>,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<Schemas.TempFood, GetFoodByIdError, TData>(
    queryKeyFn({
      path: "/foods/{fdc_id}",
      operationId: "getFoodById",
      variables,
    }),
    ({ signal }) =>
      fetchGetFoodById({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetIngredientByIdPathParams = {
  /**
   * The id of the ingredient to get into
   */
  ingredientId: string;
};

export type GetIngredientByIdError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type GetIngredientByIdVariables = {
  pathParams: GetIngredientByIdPathParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchGetIngredientById = (
  variables: GetIngredientByIdVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.IngredientWrapper,
    GetIngredientByIdError,
    undefined,
    {},
    {},
    GetIngredientByIdPathParams
  >({
    url: "/ingredients/{ingredientId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * todo
 */
export const useGetIngredientById = <TData = Schemas.IngredientWrapper>(
  variables: GetIngredientByIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.IngredientWrapper,
      GetIngredientByIdError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<
    Schemas.IngredientWrapper,
    GetIngredientByIdError,
    TData
  >(
    queryKeyFn({
      path: "/ingredients/{ingredient_id}",
      operationId: "getIngredientById",
      variables,
    }),
    ({ signal }) =>
      fetchGetIngredientById({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type SearchFoodsQueryParams = {
  /**
   * The number of items to skip before starting to collect the result set.
   *
   * @minimum 0
   */
  offset?: number;
  /**
   * The numbers of items to return.
   *
   * @minimum 1
   * @maximum 50
   * @default 20
   */
  limit?: number;
  /**
   * The search query (name).
   */
  name: string;
};

export type SearchFoodsError = Fetcher.ErrorWrapper<{
  status: Exclude<ClientErrorStatus | ServerErrorStatus, 200>;
  payload: Schemas.Error;
}>;

export type SearchFoodsVariables = {
  queryParams: SearchFoodsQueryParams;
} & GourdApiContext["fetcherOptions"];

/**
 * todo
 */
export const fetchSearchFoods = (
  variables: SearchFoodsVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.FoodSearchResult,
    SearchFoodsError,
    undefined,
    {},
    SearchFoodsQueryParams,
    {}
  >({ url: "/foods/search", method: "get", ...variables, signal });

/**
 * todo
 */
export const useSearchFoods = <TData = Schemas.FoodSearchResult>(
  variables: SearchFoodsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FoodSearchResult,
      SearchFoodsError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<Schemas.FoodSearchResult, SearchFoodsError, TData>(
    queryKeyFn({
      path: "/foods/search",
      operationId: "searchFoods",
      variables,
    }),
    ({ signal }) =>
      fetchSearchFoods({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type GetFoodsByIdsQueryParams = {
  /**
   * ids
   */
  fdc_id: number[];
};

export type GetFoodsByIdsError = Fetcher.ErrorWrapper<undefined>;

export type GetFoodsByIdsVariables = {
  queryParams: GetFoodsByIdsQueryParams;
} & GourdApiContext["fetcherOptions"];

/**
 * get foods by ids
 */
export const fetchGetFoodsByIds = (
  variables: GetFoodsByIdsVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    Schemas.PaginatedFoods,
    GetFoodsByIdsError,
    undefined,
    {},
    GetFoodsByIdsQueryParams,
    {}
  >({ url: "/foods/bulk", method: "get", ...variables, signal });

/**
 * get foods by ids
 */
export const useGetFoodsByIds = <TData = Schemas.PaginatedFoods>(
  variables: GetFoodsByIdsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PaginatedFoods,
      GetFoodsByIdsError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<Schemas.PaginatedFoods, GetFoodsByIdsError, TData>(
    queryKeyFn({
      path: "/foods/bulk",
      operationId: "getFoodsByIds",
      variables,
    }),
    ({ signal }) =>
      fetchGetFoodsByIds({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type RecipeDependenciesError = Fetcher.ErrorWrapper<undefined>;

export type RecipeDependenciesResponse = {
  /**
   * all
   */
  items?: Schemas.RecipeDependency[];
};

export type RecipeDependenciesVariables = GourdApiContext["fetcherOptions"];

/**
 * recipe dependencies
 */
export const fetchRecipeDependencies = (
  variables: RecipeDependenciesVariables,
  signal?: AbortSignal
) =>
  gourdApiFetch<
    RecipeDependenciesResponse,
    RecipeDependenciesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/data/recipe_dependencies", method: "get", ...variables, signal });

/**
 * recipe dependencies
 */
export const useRecipeDependencies = <TData = RecipeDependenciesResponse>(
  variables: RecipeDependenciesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RecipeDependenciesResponse,
      RecipeDependenciesError,
      TData
    >,
    "queryKey" | "queryFn"
  >
) => {
  const { fetcherOptions, queryOptions, queryKeyFn } =
    useGourdApiContext(options);
  return reactQuery.useQuery<
    RecipeDependenciesResponse,
    RecipeDependenciesError,
    TData
  >(
    queryKeyFn({
      path: "/data/recipe_dependencies",
      operationId: "recipeDependencies",
      variables,
    }),
    ({ signal }) =>
      fetchRecipeDependencies({ ...fetcherOptions, ...variables }, signal),
    {
      ...options,
      ...queryOptions,
    }
  );
};

export type QueryOperation =
  | {
      path: "/config";
      operationId: "getConfig";
      variables: GetConfigVariables;
    }
  | {
      path: "/sync";
      operationId: "doSync";
      variables: DoSyncVariables;
    }
  | {
      path: "/photos";
      operationId: "listPhotos";
      variables: ListPhotosVariables;
    }
  | {
      path: "/albums";
      operationId: "listAllAlbums";
      variables: ListAllAlbumsVariables;
    }
  | {
      path: "/search";
      operationId: "search";
      variables: SearchVariables;
    }
  | {
      path: "/meals";
      operationId: "listMeals";
      variables: ListMealsVariables;
    }
  | {
      path: "/meals/{meal_id}";
      operationId: "getMealById";
      variables: GetMealByIdVariables;
    }
  | {
      path: "/ingredients";
      operationId: "listIngredients";
      variables: ListIngredientsVariables;
    }
  | {
      path: "/recipes";
      operationId: "listRecipes";
      variables: ListRecipesVariables;
    }
  | {
      path: "/recipes/{recipe_id}/latex";
      operationId: "getLatexByRecipeId";
      variables: GetLatexByRecipeIdVariables;
    }
  | {
      path: "/recipes/{recipe_id}";
      operationId: "getRecipeById";
      variables: GetRecipeByIdVariables;
    }
  | {
      path: "/recipes/bulk";
      operationId: "getRecipesByIds";
      variables: GetRecipesByIdsVariables;
    }
  | {
      path: "/foods/{fdc_id}";
      operationId: "getFoodById";
      variables: GetFoodByIdVariables;
    }
  | {
      path: "/ingredients/{ingredient_id}";
      operationId: "getIngredientById";
      variables: GetIngredientByIdVariables;
    }
  | {
      path: "/foods/search";
      operationId: "searchFoods";
      variables: SearchFoodsVariables;
    }
  | {
      path: "/foods/bulk";
      operationId: "getFoodsByIds";
      variables: GetFoodsByIdsVariables;
    }
  | {
      path: "/data/recipe_dependencies";
      operationId: "recipeDependencies";
      variables: RecipeDependenciesVariables;
    };
