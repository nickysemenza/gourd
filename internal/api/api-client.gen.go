// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAllAlbums request
	ListAllAlbums(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuthLogin request
	AuthLogin(ctx context.Context, params *AuthLoginParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecipeDependencies request
	RecipeDependencies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFoodsByIds request
	GetFoodsByIds(ctx context.Context, params *GetFoodsByIdsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchFoods request
	SearchFoods(ctx context.Context, params *SearchFoodsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFoodById request
	GetFoodById(ctx context.Context, fdcId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIngredients request
	ListIngredients(ctx context.Context, params *ListIngredientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIngredientsWithBody request with any body
	CreateIngredientsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIngredients(ctx context.Context, body CreateIngredientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIngredientById request
	GetIngredientById(ctx context.Context, ingredientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssociateFoodWithIngredient request
	AssociateFoodWithIngredient(ctx context.Context, ingredientId string, params *AssociateFoodWithIngredientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ConvertIngredientToRecipe request
	ConvertIngredientToRecipe(ctx context.Context, ingredientId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MergeIngredientsWithBody request with any body
	MergeIngredientsWithBody(ctx context.Context, ingredientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MergeIngredients(ctx context.Context, ingredientId string, body MergeIngredientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMeals request
	ListMeals(ctx context.Context, params *ListMealsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMealById request
	GetMealById(ctx context.Context, mealId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRecipesForMealWithBody request with any body
	UpdateRecipesForMealWithBody(ctx context.Context, mealId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRecipesForMeal(ctx context.Context, mealId string, body UpdateRecipesForMealJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LoadIngredientMappingsWithBody request with any body
	LoadIngredientMappingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LoadIngredientMappings(ctx context.Context, body LoadIngredientMappingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPhotos request
	ListPhotos(ctx context.Context, params *ListPhotosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRecipes request
	ListRecipes(ctx context.Context, params *ListRecipesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRecipesWithBody request with any body
	CreateRecipesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRecipes(ctx context.Context, body CreateRecipesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecipesByIds request
	GetRecipesByIds(ctx context.Context, params *GetRecipesByIdsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScrapeRecipeWithBody request with any body
	ScrapeRecipeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ScrapeRecipe(ctx context.Context, body ScrapeRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SumRecipesWithBody request with any body
	SumRecipesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SumRecipes(ctx context.Context, body SumRecipesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecipeById request
	GetRecipeById(ctx context.Context, recipeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLatexByRecipeId request
	GetLatexByRecipeId(ctx context.Context, recipeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search request
	Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DoSync request
	DoSync(ctx context.Context, params *DoSyncParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAllAlbums(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAllAlbumsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuthLogin(ctx context.Context, params *AuthLoginParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuthLoginRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecipeDependencies(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecipeDependenciesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFoodsByIds(ctx context.Context, params *GetFoodsByIdsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFoodsByIdsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchFoods(ctx context.Context, params *SearchFoodsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchFoodsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFoodById(ctx context.Context, fdcId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFoodByIdRequest(c.Server, fdcId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIngredients(ctx context.Context, params *ListIngredientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIngredientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIngredientsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIngredientsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIngredients(ctx context.Context, body CreateIngredientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIngredientsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIngredientById(ctx context.Context, ingredientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIngredientByIdRequest(c.Server, ingredientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssociateFoodWithIngredient(ctx context.Context, ingredientId string, params *AssociateFoodWithIngredientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssociateFoodWithIngredientRequest(c.Server, ingredientId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ConvertIngredientToRecipe(ctx context.Context, ingredientId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewConvertIngredientToRecipeRequest(c.Server, ingredientId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIngredientsWithBody(ctx context.Context, ingredientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIngredientsRequestWithBody(c.Server, ingredientId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MergeIngredients(ctx context.Context, ingredientId string, body MergeIngredientsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMergeIngredientsRequest(c.Server, ingredientId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMeals(ctx context.Context, params *ListMealsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMealsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMealById(ctx context.Context, mealId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMealByIdRequest(c.Server, mealId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecipesForMealWithBody(ctx context.Context, mealId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecipesForMealRequestWithBody(c.Server, mealId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRecipesForMeal(ctx context.Context, mealId string, body UpdateRecipesForMealJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRecipesForMealRequest(c.Server, mealId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadIngredientMappingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadIngredientMappingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LoadIngredientMappings(ctx context.Context, body LoadIngredientMappingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLoadIngredientMappingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPhotos(ctx context.Context, params *ListPhotosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPhotosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRecipes(ctx context.Context, params *ListRecipesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRecipesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRecipesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRecipesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRecipes(ctx context.Context, body CreateRecipesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRecipesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecipesByIds(ctx context.Context, params *GetRecipesByIdsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecipesByIdsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScrapeRecipeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScrapeRecipeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScrapeRecipe(ctx context.Context, body ScrapeRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScrapeRecipeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SumRecipesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSumRecipesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SumRecipes(ctx context.Context, body SumRecipesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSumRecipesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecipeById(ctx context.Context, recipeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecipeByIdRequest(c.Server, recipeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLatexByRecipeId(ctx context.Context, recipeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLatexByRecipeIdRequest(c.Server, recipeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DoSync(ctx context.Context, params *DoSyncParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDoSyncRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAllAlbumsRequest generates requests for ListAllAlbums
func NewListAllAlbumsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/albums")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuthLoginRequest generates requests for AuthLogin
func NewAuthLoginRequest(server string, params *AuthLoginParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "code", runtime.ParamLocationQuery, params.Code); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRecipeDependenciesRequest generates requests for RecipeDependencies
func NewRecipeDependenciesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/data/recipe_dependencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFoodsByIdsRequest generates requests for GetFoodsByIds
func NewGetFoodsByIdsRequest(server string, params *GetFoodsByIdsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/foods/bulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "fdc_id", runtime.ParamLocationQuery, params.FdcId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchFoodsRequest generates requests for SearchFoods
func NewSearchFoodsRequest(server string, params *SearchFoodsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/foods/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFoodByIdRequest generates requests for GetFoodById
func NewGetFoodByIdRequest(server string, fdcId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fdc_id", runtime.ParamLocationPath, fdcId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/foods/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIngredientsRequest generates requests for ListIngredients
func NewListIngredientsRequest(server string, params *ListIngredientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingredients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IngredientId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "ingredient_id", runtime.ParamLocationQuery, *params.IngredientId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIngredientsRequest calls the generic CreateIngredients builder with application/json body
func NewCreateIngredientsRequest(server string, body CreateIngredientsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIngredientsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIngredientsRequestWithBody generates requests for CreateIngredients with any type of body
func NewCreateIngredientsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingredients")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIngredientByIdRequest generates requests for GetIngredientById
func NewGetIngredientByIdRequest(server string, ingredientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ingredientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingredients/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssociateFoodWithIngredientRequest generates requests for AssociateFoodWithIngredient
func NewAssociateFoodWithIngredientRequest(server string, ingredientId string, params *AssociateFoodWithIngredientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ingredientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingredients/%s/associate_food", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fdc_id", runtime.ParamLocationQuery, params.FdcId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewConvertIngredientToRecipeRequest generates requests for ConvertIngredientToRecipe
func NewConvertIngredientToRecipeRequest(server string, ingredientId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ingredientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingredients/%s/convert_to_recipe", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMergeIngredientsRequest calls the generic MergeIngredients builder with application/json body
func NewMergeIngredientsRequest(server string, ingredientId string, body MergeIngredientsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMergeIngredientsRequestWithBody(server, ingredientId, "application/json", bodyReader)
}

// NewMergeIngredientsRequestWithBody generates requests for MergeIngredients with any type of body
func NewMergeIngredientsRequestWithBody(server string, ingredientId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ingredientId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingredients/%s/merge", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMealsRequest generates requests for ListMeals
func NewListMealsRequest(server string, params *ListMealsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMealByIdRequest generates requests for GetMealById
func NewGetMealByIdRequest(server string, mealId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, mealId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meals/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRecipesForMealRequest calls the generic UpdateRecipesForMeal builder with application/json body
func NewUpdateRecipesForMealRequest(server string, mealId string, body UpdateRecipesForMealJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRecipesForMealRequestWithBody(server, mealId, "application/json", bodyReader)
}

// NewUpdateRecipesForMealRequestWithBody generates requests for UpdateRecipesForMeal with any type of body
func NewUpdateRecipesForMealRequestWithBody(server string, mealId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, mealId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meals/%s/recipes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLoadIngredientMappingsRequest calls the generic LoadIngredientMappings builder with application/json body
func NewLoadIngredientMappingsRequest(server string, body LoadIngredientMappingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLoadIngredientMappingsRequestWithBody(server, "application/json", bodyReader)
}

// NewLoadIngredientMappingsRequestWithBody generates requests for LoadIngredientMappings with any type of body
func NewLoadIngredientMappingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meta/load_ingredient_mappings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPhotosRequest generates requests for ListPhotos
func NewListPhotosRequest(server string, params *ListPhotosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/photos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRecipesRequest generates requests for ListRecipes
func NewListRecipesRequest(server string, params *ListRecipesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recipes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRecipesRequest calls the generic CreateRecipes builder with application/json body
func NewCreateRecipesRequest(server string, body CreateRecipesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRecipesRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRecipesRequestWithBody generates requests for CreateRecipes with any type of body
func NewCreateRecipesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recipes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRecipesByIdsRequest generates requests for GetRecipesByIds
func NewGetRecipesByIdsRequest(server string, params *GetRecipesByIdsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recipes/bulk")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "recipe_id", runtime.ParamLocationQuery, params.RecipeId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScrapeRecipeRequest calls the generic ScrapeRecipe builder with application/json body
func NewScrapeRecipeRequest(server string, body ScrapeRecipeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewScrapeRecipeRequestWithBody(server, "application/json", bodyReader)
}

// NewScrapeRecipeRequestWithBody generates requests for ScrapeRecipe with any type of body
func NewScrapeRecipeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recipes/scrape")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSumRecipesRequest calls the generic SumRecipes builder with application/json body
func NewSumRecipesRequest(server string, body SumRecipesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSumRecipesRequestWithBody(server, "application/json", bodyReader)
}

// NewSumRecipesRequestWithBody generates requests for SumRecipes with any type of body
func NewSumRecipesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recipes/sum")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRecipeByIdRequest generates requests for GetRecipeById
func NewGetRecipeByIdRequest(server string, recipeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, recipeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recipes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLatexByRecipeIdRequest generates requests for GetLatexByRecipeId
func NewGetLatexByRecipeIdRequest(server string, recipeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, recipeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recipes/%s/latex", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, params *SearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDoSyncRequest generates requests for DoSync
func NewDoSyncRequest(server string, params *DoSyncParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sync")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "lookback_days", runtime.ParamLocationQuery, params.LookbackDays); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAllAlbumsWithResponse request
	ListAllAlbumsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllAlbumsResponse, error)

	// AuthLoginWithResponse request
	AuthLoginWithResponse(ctx context.Context, params *AuthLoginParams, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error)

	// GetConfigWithResponse request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// RecipeDependenciesWithResponse request
	RecipeDependenciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RecipeDependenciesResponse, error)

	// GetFoodsByIdsWithResponse request
	GetFoodsByIdsWithResponse(ctx context.Context, params *GetFoodsByIdsParams, reqEditors ...RequestEditorFn) (*GetFoodsByIdsResponse, error)

	// SearchFoodsWithResponse request
	SearchFoodsWithResponse(ctx context.Context, params *SearchFoodsParams, reqEditors ...RequestEditorFn) (*SearchFoodsResponse, error)

	// GetFoodByIdWithResponse request
	GetFoodByIdWithResponse(ctx context.Context, fdcId int, reqEditors ...RequestEditorFn) (*GetFoodByIdResponse, error)

	// ListIngredientsWithResponse request
	ListIngredientsWithResponse(ctx context.Context, params *ListIngredientsParams, reqEditors ...RequestEditorFn) (*ListIngredientsResponse, error)

	// CreateIngredientsWithBodyWithResponse request with any body
	CreateIngredientsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIngredientsResponse, error)

	CreateIngredientsWithResponse(ctx context.Context, body CreateIngredientsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIngredientsResponse, error)

	// GetIngredientByIdWithResponse request
	GetIngredientByIdWithResponse(ctx context.Context, ingredientId string, reqEditors ...RequestEditorFn) (*GetIngredientByIdResponse, error)

	// AssociateFoodWithIngredientWithResponse request
	AssociateFoodWithIngredientWithResponse(ctx context.Context, ingredientId string, params *AssociateFoodWithIngredientParams, reqEditors ...RequestEditorFn) (*AssociateFoodWithIngredientResponse, error)

	// ConvertIngredientToRecipeWithResponse request
	ConvertIngredientToRecipeWithResponse(ctx context.Context, ingredientId string, reqEditors ...RequestEditorFn) (*ConvertIngredientToRecipeResponse, error)

	// MergeIngredientsWithBodyWithResponse request with any body
	MergeIngredientsWithBodyWithResponse(ctx context.Context, ingredientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIngredientsResponse, error)

	MergeIngredientsWithResponse(ctx context.Context, ingredientId string, body MergeIngredientsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIngredientsResponse, error)

	// ListMealsWithResponse request
	ListMealsWithResponse(ctx context.Context, params *ListMealsParams, reqEditors ...RequestEditorFn) (*ListMealsResponse, error)

	// GetMealByIdWithResponse request
	GetMealByIdWithResponse(ctx context.Context, mealId string, reqEditors ...RequestEditorFn) (*GetMealByIdResponse, error)

	// UpdateRecipesForMealWithBodyWithResponse request with any body
	UpdateRecipesForMealWithBodyWithResponse(ctx context.Context, mealId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecipesForMealResponse, error)

	UpdateRecipesForMealWithResponse(ctx context.Context, mealId string, body UpdateRecipesForMealJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecipesForMealResponse, error)

	// LoadIngredientMappingsWithBodyWithResponse request with any body
	LoadIngredientMappingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoadIngredientMappingsResponse, error)

	LoadIngredientMappingsWithResponse(ctx context.Context, body LoadIngredientMappingsJSONRequestBody, reqEditors ...RequestEditorFn) (*LoadIngredientMappingsResponse, error)

	// ListPhotosWithResponse request
	ListPhotosWithResponse(ctx context.Context, params *ListPhotosParams, reqEditors ...RequestEditorFn) (*ListPhotosResponse, error)

	// ListRecipesWithResponse request
	ListRecipesWithResponse(ctx context.Context, params *ListRecipesParams, reqEditors ...RequestEditorFn) (*ListRecipesResponse, error)

	// CreateRecipesWithBodyWithResponse request with any body
	CreateRecipesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRecipesResponse, error)

	CreateRecipesWithResponse(ctx context.Context, body CreateRecipesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRecipesResponse, error)

	// GetRecipesByIdsWithResponse request
	GetRecipesByIdsWithResponse(ctx context.Context, params *GetRecipesByIdsParams, reqEditors ...RequestEditorFn) (*GetRecipesByIdsResponse, error)

	// ScrapeRecipeWithBodyWithResponse request with any body
	ScrapeRecipeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScrapeRecipeResponse, error)

	ScrapeRecipeWithResponse(ctx context.Context, body ScrapeRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*ScrapeRecipeResponse, error)

	// SumRecipesWithBodyWithResponse request with any body
	SumRecipesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SumRecipesResponse, error)

	SumRecipesWithResponse(ctx context.Context, body SumRecipesJSONRequestBody, reqEditors ...RequestEditorFn) (*SumRecipesResponse, error)

	// GetRecipeByIdWithResponse request
	GetRecipeByIdWithResponse(ctx context.Context, recipeId string, reqEditors ...RequestEditorFn) (*GetRecipeByIdResponse, error)

	// GetLatexByRecipeIdWithResponse request
	GetLatexByRecipeIdWithResponse(ctx context.Context, recipeId string, reqEditors ...RequestEditorFn) (*GetLatexByRecipeIdResponse, error)

	// SearchWithResponse request
	SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error)

	// DoSyncWithResponse request
	DoSyncWithResponse(ctx context.Context, params *DoSyncParams, reqEditors ...RequestEditorFn) (*DoSyncResponse, error)
}

type ListAllAlbumsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Albums The list of albums
		Albums *[]GooglePhotosAlbum `json:"albums,omitempty"`
	}
	JSONDefault *Error
}

// Status returns HTTPResponse.Status
func (r ListAllAlbumsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAllAlbumsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuthLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthResp
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AuthLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuthLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConfigData
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecipeDependenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Items all
		Items *[]RecipeDependency `json:"items,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r RecipeDependenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecipeDependenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFoodsByIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedFoods
}

// Status returns HTTPResponse.Status
func (r GetFoodsByIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFoodsByIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchFoodsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FoodSearchResult
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SearchFoodsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchFoodsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFoodByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TempFood
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetFoodByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFoodByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIngredientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedIngredients
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListIngredientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIngredientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIngredientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Ingredient
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateIngredientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIngredientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIngredientByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IngredientWrapper
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetIngredientByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIngredientByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssociateFoodWithIngredientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RecipeDetail
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r AssociateFoodWithIngredientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssociateFoodWithIngredientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ConvertIngredientToRecipeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RecipeDetail
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ConvertIngredientToRecipeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ConvertIngredientToRecipeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MergeIngredientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Ingredient
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r MergeIngredientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MergeIngredientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMealsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedMeals
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListMealsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMealsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMealByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Meal
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetMealByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMealByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRecipesForMealResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Meal
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r UpdateRecipesForMealResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRecipesForMealResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LoadIngredientMappingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r LoadIngredientMappingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LoadIngredientMappingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPhotosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedPhotos
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListPhotosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPhotosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRecipesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedRecipeWrappers
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ListRecipesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRecipesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRecipesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RecipeWrapper
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r CreateRecipesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRecipesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecipesByIdsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedRecipeWrappers
}

// Status returns HTTPResponse.Status
func (r GetRecipesByIdsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecipesByIdsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScrapeRecipeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RecipeWrapper
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r ScrapeRecipeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScrapeRecipeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SumRecipesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SumsResponse
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SumRecipesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SumRecipesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecipeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RecipeWrapper
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetRecipeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecipeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLatexByRecipeIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r GetLatexByRecipeIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLatexByRecipeIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchResult
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r SearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DoSyncResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSONDefault  *Error
}

// Status returns HTTPResponse.Status
func (r DoSyncResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DoSyncResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAllAlbumsWithResponse request returning *ListAllAlbumsResponse
func (c *ClientWithResponses) ListAllAlbumsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListAllAlbumsResponse, error) {
	rsp, err := c.ListAllAlbums(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAllAlbumsResponse(rsp)
}

// AuthLoginWithResponse request returning *AuthLoginResponse
func (c *ClientWithResponses) AuthLoginWithResponse(ctx context.Context, params *AuthLoginParams, reqEditors ...RequestEditorFn) (*AuthLoginResponse, error) {
	rsp, err := c.AuthLogin(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuthLoginResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// RecipeDependenciesWithResponse request returning *RecipeDependenciesResponse
func (c *ClientWithResponses) RecipeDependenciesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*RecipeDependenciesResponse, error) {
	rsp, err := c.RecipeDependencies(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecipeDependenciesResponse(rsp)
}

// GetFoodsByIdsWithResponse request returning *GetFoodsByIdsResponse
func (c *ClientWithResponses) GetFoodsByIdsWithResponse(ctx context.Context, params *GetFoodsByIdsParams, reqEditors ...RequestEditorFn) (*GetFoodsByIdsResponse, error) {
	rsp, err := c.GetFoodsByIds(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFoodsByIdsResponse(rsp)
}

// SearchFoodsWithResponse request returning *SearchFoodsResponse
func (c *ClientWithResponses) SearchFoodsWithResponse(ctx context.Context, params *SearchFoodsParams, reqEditors ...RequestEditorFn) (*SearchFoodsResponse, error) {
	rsp, err := c.SearchFoods(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchFoodsResponse(rsp)
}

// GetFoodByIdWithResponse request returning *GetFoodByIdResponse
func (c *ClientWithResponses) GetFoodByIdWithResponse(ctx context.Context, fdcId int, reqEditors ...RequestEditorFn) (*GetFoodByIdResponse, error) {
	rsp, err := c.GetFoodById(ctx, fdcId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFoodByIdResponse(rsp)
}

// ListIngredientsWithResponse request returning *ListIngredientsResponse
func (c *ClientWithResponses) ListIngredientsWithResponse(ctx context.Context, params *ListIngredientsParams, reqEditors ...RequestEditorFn) (*ListIngredientsResponse, error) {
	rsp, err := c.ListIngredients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIngredientsResponse(rsp)
}

// CreateIngredientsWithBodyWithResponse request with arbitrary body returning *CreateIngredientsResponse
func (c *ClientWithResponses) CreateIngredientsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIngredientsResponse, error) {
	rsp, err := c.CreateIngredientsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIngredientsResponse(rsp)
}

func (c *ClientWithResponses) CreateIngredientsWithResponse(ctx context.Context, body CreateIngredientsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIngredientsResponse, error) {
	rsp, err := c.CreateIngredients(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIngredientsResponse(rsp)
}

// GetIngredientByIdWithResponse request returning *GetIngredientByIdResponse
func (c *ClientWithResponses) GetIngredientByIdWithResponse(ctx context.Context, ingredientId string, reqEditors ...RequestEditorFn) (*GetIngredientByIdResponse, error) {
	rsp, err := c.GetIngredientById(ctx, ingredientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIngredientByIdResponse(rsp)
}

// AssociateFoodWithIngredientWithResponse request returning *AssociateFoodWithIngredientResponse
func (c *ClientWithResponses) AssociateFoodWithIngredientWithResponse(ctx context.Context, ingredientId string, params *AssociateFoodWithIngredientParams, reqEditors ...RequestEditorFn) (*AssociateFoodWithIngredientResponse, error) {
	rsp, err := c.AssociateFoodWithIngredient(ctx, ingredientId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAssociateFoodWithIngredientResponse(rsp)
}

// ConvertIngredientToRecipeWithResponse request returning *ConvertIngredientToRecipeResponse
func (c *ClientWithResponses) ConvertIngredientToRecipeWithResponse(ctx context.Context, ingredientId string, reqEditors ...RequestEditorFn) (*ConvertIngredientToRecipeResponse, error) {
	rsp, err := c.ConvertIngredientToRecipe(ctx, ingredientId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseConvertIngredientToRecipeResponse(rsp)
}

// MergeIngredientsWithBodyWithResponse request with arbitrary body returning *MergeIngredientsResponse
func (c *ClientWithResponses) MergeIngredientsWithBodyWithResponse(ctx context.Context, ingredientId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MergeIngredientsResponse, error) {
	rsp, err := c.MergeIngredientsWithBody(ctx, ingredientId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIngredientsResponse(rsp)
}

func (c *ClientWithResponses) MergeIngredientsWithResponse(ctx context.Context, ingredientId string, body MergeIngredientsJSONRequestBody, reqEditors ...RequestEditorFn) (*MergeIngredientsResponse, error) {
	rsp, err := c.MergeIngredients(ctx, ingredientId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMergeIngredientsResponse(rsp)
}

// ListMealsWithResponse request returning *ListMealsResponse
func (c *ClientWithResponses) ListMealsWithResponse(ctx context.Context, params *ListMealsParams, reqEditors ...RequestEditorFn) (*ListMealsResponse, error) {
	rsp, err := c.ListMeals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMealsResponse(rsp)
}

// GetMealByIdWithResponse request returning *GetMealByIdResponse
func (c *ClientWithResponses) GetMealByIdWithResponse(ctx context.Context, mealId string, reqEditors ...RequestEditorFn) (*GetMealByIdResponse, error) {
	rsp, err := c.GetMealById(ctx, mealId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMealByIdResponse(rsp)
}

// UpdateRecipesForMealWithBodyWithResponse request with arbitrary body returning *UpdateRecipesForMealResponse
func (c *ClientWithResponses) UpdateRecipesForMealWithBodyWithResponse(ctx context.Context, mealId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRecipesForMealResponse, error) {
	rsp, err := c.UpdateRecipesForMealWithBody(ctx, mealId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecipesForMealResponse(rsp)
}

func (c *ClientWithResponses) UpdateRecipesForMealWithResponse(ctx context.Context, mealId string, body UpdateRecipesForMealJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRecipesForMealResponse, error) {
	rsp, err := c.UpdateRecipesForMeal(ctx, mealId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRecipesForMealResponse(rsp)
}

// LoadIngredientMappingsWithBodyWithResponse request with arbitrary body returning *LoadIngredientMappingsResponse
func (c *ClientWithResponses) LoadIngredientMappingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LoadIngredientMappingsResponse, error) {
	rsp, err := c.LoadIngredientMappingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadIngredientMappingsResponse(rsp)
}

func (c *ClientWithResponses) LoadIngredientMappingsWithResponse(ctx context.Context, body LoadIngredientMappingsJSONRequestBody, reqEditors ...RequestEditorFn) (*LoadIngredientMappingsResponse, error) {
	rsp, err := c.LoadIngredientMappings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLoadIngredientMappingsResponse(rsp)
}

// ListPhotosWithResponse request returning *ListPhotosResponse
func (c *ClientWithResponses) ListPhotosWithResponse(ctx context.Context, params *ListPhotosParams, reqEditors ...RequestEditorFn) (*ListPhotosResponse, error) {
	rsp, err := c.ListPhotos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPhotosResponse(rsp)
}

// ListRecipesWithResponse request returning *ListRecipesResponse
func (c *ClientWithResponses) ListRecipesWithResponse(ctx context.Context, params *ListRecipesParams, reqEditors ...RequestEditorFn) (*ListRecipesResponse, error) {
	rsp, err := c.ListRecipes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRecipesResponse(rsp)
}

// CreateRecipesWithBodyWithResponse request with arbitrary body returning *CreateRecipesResponse
func (c *ClientWithResponses) CreateRecipesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRecipesResponse, error) {
	rsp, err := c.CreateRecipesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRecipesResponse(rsp)
}

func (c *ClientWithResponses) CreateRecipesWithResponse(ctx context.Context, body CreateRecipesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRecipesResponse, error) {
	rsp, err := c.CreateRecipes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRecipesResponse(rsp)
}

// GetRecipesByIdsWithResponse request returning *GetRecipesByIdsResponse
func (c *ClientWithResponses) GetRecipesByIdsWithResponse(ctx context.Context, params *GetRecipesByIdsParams, reqEditors ...RequestEditorFn) (*GetRecipesByIdsResponse, error) {
	rsp, err := c.GetRecipesByIds(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecipesByIdsResponse(rsp)
}

// ScrapeRecipeWithBodyWithResponse request with arbitrary body returning *ScrapeRecipeResponse
func (c *ClientWithResponses) ScrapeRecipeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ScrapeRecipeResponse, error) {
	rsp, err := c.ScrapeRecipeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScrapeRecipeResponse(rsp)
}

func (c *ClientWithResponses) ScrapeRecipeWithResponse(ctx context.Context, body ScrapeRecipeJSONRequestBody, reqEditors ...RequestEditorFn) (*ScrapeRecipeResponse, error) {
	rsp, err := c.ScrapeRecipe(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScrapeRecipeResponse(rsp)
}

// SumRecipesWithBodyWithResponse request with arbitrary body returning *SumRecipesResponse
func (c *ClientWithResponses) SumRecipesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SumRecipesResponse, error) {
	rsp, err := c.SumRecipesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSumRecipesResponse(rsp)
}

func (c *ClientWithResponses) SumRecipesWithResponse(ctx context.Context, body SumRecipesJSONRequestBody, reqEditors ...RequestEditorFn) (*SumRecipesResponse, error) {
	rsp, err := c.SumRecipes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSumRecipesResponse(rsp)
}

// GetRecipeByIdWithResponse request returning *GetRecipeByIdResponse
func (c *ClientWithResponses) GetRecipeByIdWithResponse(ctx context.Context, recipeId string, reqEditors ...RequestEditorFn) (*GetRecipeByIdResponse, error) {
	rsp, err := c.GetRecipeById(ctx, recipeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecipeByIdResponse(rsp)
}

// GetLatexByRecipeIdWithResponse request returning *GetLatexByRecipeIdResponse
func (c *ClientWithResponses) GetLatexByRecipeIdWithResponse(ctx context.Context, recipeId string, reqEditors ...RequestEditorFn) (*GetLatexByRecipeIdResponse, error) {
	rsp, err := c.GetLatexByRecipeId(ctx, recipeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLatexByRecipeIdResponse(rsp)
}

// SearchWithResponse request returning *SearchResponse
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResponse, error) {
	rsp, err := c.Search(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResponse(rsp)
}

// DoSyncWithResponse request returning *DoSyncResponse
func (c *ClientWithResponses) DoSyncWithResponse(ctx context.Context, params *DoSyncParams, reqEditors ...RequestEditorFn) (*DoSyncResponse, error) {
	rsp, err := c.DoSync(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDoSyncResponse(rsp)
}

// ParseListAllAlbumsResponse parses an HTTP response from a ListAllAlbumsWithResponse call
func ParseListAllAlbumsResponse(rsp *http.Response) (*ListAllAlbumsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAllAlbumsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Albums The list of albums
			Albums *[]GooglePhotosAlbum `json:"albums,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAuthLoginResponse parses an HTTP response from a AuthLoginWithResponse call
func ParseAuthLoginResponse(rsp *http.Response) (*AuthLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuthLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConfigData
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRecipeDependenciesResponse parses an HTTP response from a RecipeDependenciesWithResponse call
func ParseRecipeDependenciesResponse(rsp *http.Response) (*RecipeDependenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecipeDependenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Items all
			Items *[]RecipeDependency `json:"items,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFoodsByIdsResponse parses an HTTP response from a GetFoodsByIdsWithResponse call
func ParseGetFoodsByIdsResponse(rsp *http.Response) (*GetFoodsByIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFoodsByIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedFoods
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchFoodsResponse parses an HTTP response from a SearchFoodsWithResponse call
func ParseSearchFoodsResponse(rsp *http.Response) (*SearchFoodsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchFoodsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FoodSearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFoodByIdResponse parses an HTTP response from a GetFoodByIdWithResponse call
func ParseGetFoodByIdResponse(rsp *http.Response) (*GetFoodByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFoodByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TempFood
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListIngredientsResponse parses an HTTP response from a ListIngredientsWithResponse call
func ParseListIngredientsResponse(rsp *http.Response) (*ListIngredientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIngredientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedIngredients
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateIngredientsResponse parses an HTTP response from a CreateIngredientsWithResponse call
func ParseCreateIngredientsResponse(rsp *http.Response) (*CreateIngredientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIngredientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Ingredient
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetIngredientByIdResponse parses an HTTP response from a GetIngredientByIdWithResponse call
func ParseGetIngredientByIdResponse(rsp *http.Response) (*GetIngredientByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIngredientByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IngredientWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAssociateFoodWithIngredientResponse parses an HTTP response from a AssociateFoodWithIngredientWithResponse call
func ParseAssociateFoodWithIngredientResponse(rsp *http.Response) (*AssociateFoodWithIngredientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AssociateFoodWithIngredientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RecipeDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseConvertIngredientToRecipeResponse parses an HTTP response from a ConvertIngredientToRecipeWithResponse call
func ParseConvertIngredientToRecipeResponse(rsp *http.Response) (*ConvertIngredientToRecipeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ConvertIngredientToRecipeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RecipeDetail
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseMergeIngredientsResponse parses an HTTP response from a MergeIngredientsWithResponse call
func ParseMergeIngredientsResponse(rsp *http.Response) (*MergeIngredientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MergeIngredientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Ingredient
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListMealsResponse parses an HTTP response from a ListMealsWithResponse call
func ParseListMealsResponse(rsp *http.Response) (*ListMealsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMealsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedMeals
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMealByIdResponse parses an HTTP response from a GetMealByIdWithResponse call
func ParseGetMealByIdResponse(rsp *http.Response) (*GetMealByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMealByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Meal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateRecipesForMealResponse parses an HTTP response from a UpdateRecipesForMealWithResponse call
func ParseUpdateRecipesForMealResponse(rsp *http.Response) (*UpdateRecipesForMealResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRecipesForMealResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Meal
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseLoadIngredientMappingsResponse parses an HTTP response from a LoadIngredientMappingsWithResponse call
func ParseLoadIngredientMappingsResponse(rsp *http.Response) (*LoadIngredientMappingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LoadIngredientMappingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPhotosResponse parses an HTTP response from a ListPhotosWithResponse call
func ParseListPhotosResponse(rsp *http.Response) (*ListPhotosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPhotosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedPhotos
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseListRecipesResponse parses an HTTP response from a ListRecipesWithResponse call
func ParseListRecipesResponse(rsp *http.Response) (*ListRecipesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRecipesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedRecipeWrappers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRecipesResponse parses an HTTP response from a CreateRecipesWithResponse call
func ParseCreateRecipesResponse(rsp *http.Response) (*CreateRecipesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRecipesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RecipeWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecipesByIdsResponse parses an HTTP response from a GetRecipesByIdsWithResponse call
func ParseGetRecipesByIdsResponse(rsp *http.Response) (*GetRecipesByIdsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecipesByIdsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedRecipeWrappers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseScrapeRecipeResponse parses an HTTP response from a ScrapeRecipeWithResponse call
func ParseScrapeRecipeResponse(rsp *http.Response) (*ScrapeRecipeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScrapeRecipeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RecipeWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSumRecipesResponse parses an HTTP response from a SumRecipesWithResponse call
func ParseSumRecipesResponse(rsp *http.Response) (*SumRecipesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SumRecipesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SumsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRecipeByIdResponse parses an HTTP response from a GetRecipeByIdWithResponse call
func ParseGetRecipeByIdResponse(rsp *http.Response) (*GetRecipeByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecipeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RecipeWrapper
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLatexByRecipeIdResponse parses an HTTP response from a GetLatexByRecipeIdWithResponse call
func ParseGetLatexByRecipeIdResponse(rsp *http.Response) (*GetLatexByRecipeIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLatexByRecipeIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSearchResponse parses an HTTP response from a SearchWithResponse call
func ParseSearchResponse(rsp *http.Response) (*SearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDoSyncResponse parses an HTTP response from a DoSyncWithResponse call
func ParseDoSyncResponse(rsp *http.Response) (*DoSyncResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DoSyncResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
