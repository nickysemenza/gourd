// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// Get app config
	// (GET /config)
	GetConfig(ctx echo.Context) error
	// Get foods
	// (GET /data/recipe_dependencies)
	RecipeDependencies(ctx echo.Context) error
	// Get foods
	// (GET /foods/bulk)
	GetFoodsByIds(ctx echo.Context, params GetFoodsByIdsParams) error
	// Search foods
	// (GET /foods/search)
	SearchFoods(ctx echo.Context, params SearchFoodsParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Get a specific ingredient
	// (GET /ingredients/{ingredient_id})
	GetIngredientById(ctx echo.Context, ingredientId string) error
	// Assosiates a food with a given ingredient
	// (POST /ingredients/{ingredient_id}/associate_food)
	AssociateFoodWithIngredient(ctx echo.Context, ingredientId string, params AssociateFoodWithIngredientParams) error
	// Converts an ingredient to a recipe, updating all recipes depending on it
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// Info for a specific meal
	// (GET /meals/{meal_id})
	GetMealById(ctx echo.Context, mealId string) error
	// Update the recipes associated with a given meal
	// (PATCH /meals/{meal_id}/recipes)
	UpdateRecipesForMeal(ctx echo.Context, mealId string) error
	// load mappings
	// (POST /meta/load_ingredient_mappings)
	LoadIngredientMappings(ctx echo.Context) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Get recipes
	// (GET /recipes/bulk)
	GetRecipesByIds(ctx echo.Context, params GetRecipesByIdsParams) error
	// scrape a recipe by URL
	// (POST /recipes/scrape)
	ScrapeRecipe(ctx echo.Context) error
	// sum up recipes
	// (POST /recipes/sum)
	SumRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// recipe as latex
	// (GET /recipes/{recipe_id}/latex)
	GetLatexByRecipeId(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
	// perform sync
	// (GET /sync)
	DoSync(ctx echo.Context, params DoSyncParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// GetConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfig(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetConfig(ctx)
	return err
}

// RecipeDependencies converts echo context to params.
func (w *ServerInterfaceWrapper) RecipeDependencies(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RecipeDependencies(ctx)
	return err
}

// GetFoodsByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodsByIds(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFoodsByIdsParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodsByIds(ctx, params)
	return err
}

// SearchFoods converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFoods(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFoodsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "data_types" -------------

	err = runtime.BindQueryParameter("form", true, false, "data_types", ctx.QueryParams(), &params.DataTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter data_types: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFoods(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "fdc_id", runtime.ParamLocationPath, ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "ingredient_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "ingredient_id", ctx.QueryParams(), &params.IngredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// GetIngredientById converts echo context to params.
func (w *ServerInterfaceWrapper) GetIngredientById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIngredientById(ctx, ingredientId)
	return err
}

// AssociateFoodWithIngredient converts echo context to params.
func (w *ServerInterfaceWrapper) AssociateFoodWithIngredient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssociateFoodWithIngredientParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssociateFoodWithIngredient(ctx, ingredientId, params)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// GetMealById converts echo context to params.
func (w *ServerInterfaceWrapper) GetMealById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMealById(ctx, mealId)
	return err
}

// UpdateRecipesForMeal converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRecipesForMeal(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRecipesForMeal(ctx, mealId)
	return err
}

// LoadIngredientMappings converts echo context to params.
func (w *ServerInterfaceWrapper) LoadIngredientMappings(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LoadIngredientMappings(ctx)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipesByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipesByIds(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecipesByIdsParams
	// ------------- Required query parameter "recipe_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "recipe_id", ctx.QueryParams(), &params.RecipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipesByIds(ctx, params)
	return err
}

// ScrapeRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ScrapeRecipe(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ScrapeRecipe(ctx)
	return err
}

// SumRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) SumRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SumRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// GetLatexByRecipeId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatexByRecipeId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLatexByRecipeId(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// DoSync converts echo context to params.
func (w *ServerInterfaceWrapper) DoSync(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DoSyncParams
	// ------------- Required query parameter "lookback_days" -------------

	err = runtime.BindQueryParameter("form", true, true, "lookback_days", ctx.QueryParams(), &params.LookbackDays)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lookback_days: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DoSync(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/albums", wrapper.ListAllAlbums)
	router.POST(baseURL+"/auth", wrapper.AuthLogin)
	router.GET(baseURL+"/config", wrapper.GetConfig)
	router.GET(baseURL+"/data/recipe_dependencies", wrapper.RecipeDependencies)
	router.GET(baseURL+"/foods/bulk", wrapper.GetFoodsByIds)
	router.GET(baseURL+"/foods/search", wrapper.SearchFoods)
	router.GET(baseURL+"/foods/:fdc_id", wrapper.GetFoodById)
	router.GET(baseURL+"/ingredients", wrapper.ListIngredients)
	router.POST(baseURL+"/ingredients", wrapper.CreateIngredients)
	router.GET(baseURL+"/ingredients/:ingredient_id", wrapper.GetIngredientById)
	router.POST(baseURL+"/ingredients/:ingredient_id/associate_food", wrapper.AssociateFoodWithIngredient)
	router.POST(baseURL+"/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST(baseURL+"/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET(baseURL+"/meals", wrapper.ListMeals)
	router.GET(baseURL+"/meals/:meal_id", wrapper.GetMealById)
	router.PATCH(baseURL+"/meals/:meal_id/recipes", wrapper.UpdateRecipesForMeal)
	router.POST(baseURL+"/meta/load_ingredient_mappings", wrapper.LoadIngredientMappings)
	router.GET(baseURL+"/photos", wrapper.ListPhotos)
	router.GET(baseURL+"/recipes", wrapper.ListRecipes)
	router.POST(baseURL+"/recipes", wrapper.CreateRecipes)
	router.GET(baseURL+"/recipes/bulk", wrapper.GetRecipesByIds)
	router.POST(baseURL+"/recipes/scrape", wrapper.ScrapeRecipe)
	router.POST(baseURL+"/recipes/sum", wrapper.SumRecipes)
	router.GET(baseURL+"/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET(baseURL+"/recipes/:recipe_id/latex", wrapper.GetLatexByRecipeId)
	router.GET(baseURL+"/search", wrapper.Search)
	router.GET(baseURL+"/sync", wrapper.DoSync)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
