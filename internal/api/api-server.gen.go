// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// Get app config
	// (GET /config)
	GetConfig(ctx echo.Context) error
	// Get foods
	// (GET /data/recipe_dependencies)
	RecipeDependencies(ctx echo.Context) error
	// Get foods
	// (GET /foods/bulk)
	GetFoodsByIds(ctx echo.Context, params GetFoodsByIdsParams) error
	// Search foods
	// (GET /foods/search)
	SearchFoods(ctx echo.Context, params SearchFoodsParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Get a specific ingredient
	// (GET /ingredients/{ingredient_id})
	GetIngredientById(ctx echo.Context, ingredientId string) error
	// Assosiates a food with a given ingredient
	// (POST /ingredients/{ingredient_id}/associate_food)
	AssociateFoodWithIngredient(ctx echo.Context, ingredientId string, params AssociateFoodWithIngredientParams) error
	// Converts an ingredient to a recipe, updating all recipes depending on it
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// Info for a specific meal
	// (GET /meals/{meal_id})
	GetMealById(ctx echo.Context, mealId string) error
	// Update the recipes associated with a given meal
	// (PATCH /meals/{meal_id}/recipes)
	UpdateRecipesForMeal(ctx echo.Context, mealId string) error
	// load mappings
	// (POST /meta/load_ingredient_mappings)
	LoadIngredientMappings(ctx echo.Context) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Get recipes
	// (GET /recipes/bulk)
	GetRecipesByIds(ctx echo.Context, params GetRecipesByIdsParams) error
	// scrape a recipe by URL
	// (POST /recipes/scrape)
	ScrapeRecipe(ctx echo.Context) error
	// sum up recipes
	// (POST /recipes/sum)
	SumRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// recipe as latex
	// (GET /recipes/{recipe_id}/latex)
	GetLatexByRecipeId(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
	// perform sync
	// (GET /sync)
	DoSync(ctx echo.Context, params DoSyncParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// GetConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfig(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetConfig(ctx)
	return err
}

// RecipeDependencies converts echo context to params.
func (w *ServerInterfaceWrapper) RecipeDependencies(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RecipeDependencies(ctx)
	return err
}

// GetFoodsByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodsByIds(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFoodsByIdsParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodsByIds(ctx, params)
	return err
}

// SearchFoods converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFoods(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFoodsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFoods(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "fdc_id", runtime.ParamLocationPath, ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "ingredient_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "ingredient_id", ctx.QueryParams(), &params.IngredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// GetIngredientById converts echo context to params.
func (w *ServerInterfaceWrapper) GetIngredientById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIngredientById(ctx, ingredientId)
	return err
}

// AssociateFoodWithIngredient converts echo context to params.
func (w *ServerInterfaceWrapper) AssociateFoodWithIngredient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssociateFoodWithIngredientParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssociateFoodWithIngredient(ctx, ingredientId, params)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// GetMealById converts echo context to params.
func (w *ServerInterfaceWrapper) GetMealById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMealById(ctx, mealId)
	return err
}

// UpdateRecipesForMeal converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRecipesForMeal(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRecipesForMeal(ctx, mealId)
	return err
}

// LoadIngredientMappings converts echo context to params.
func (w *ServerInterfaceWrapper) LoadIngredientMappings(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LoadIngredientMappings(ctx)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipesByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipesByIds(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecipesByIdsParams
	// ------------- Required query parameter "recipe_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "recipe_id", ctx.QueryParams(), &params.RecipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipesByIds(ctx, params)
	return err
}

// ScrapeRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ScrapeRecipe(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ScrapeRecipe(ctx)
	return err
}

// SumRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) SumRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SumRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// GetLatexByRecipeId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatexByRecipeId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLatexByRecipeId(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// DoSync converts echo context to params.
func (w *ServerInterfaceWrapper) DoSync(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DoSyncParams
	// ------------- Required query parameter "lookback_days" -------------

	err = runtime.BindQueryParameter("form", true, true, "lookback_days", ctx.QueryParams(), &params.LookbackDays)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lookback_days: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DoSync(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/albums", wrapper.ListAllAlbums)
	router.POST(baseURL+"/auth", wrapper.AuthLogin)
	router.GET(baseURL+"/config", wrapper.GetConfig)
	router.GET(baseURL+"/data/recipe_dependencies", wrapper.RecipeDependencies)
	router.GET(baseURL+"/foods/bulk", wrapper.GetFoodsByIds)
	router.GET(baseURL+"/foods/search", wrapper.SearchFoods)
	router.GET(baseURL+"/foods/:fdc_id", wrapper.GetFoodById)
	router.GET(baseURL+"/ingredients", wrapper.ListIngredients)
	router.POST(baseURL+"/ingredients", wrapper.CreateIngredients)
	router.GET(baseURL+"/ingredients/:ingredient_id", wrapper.GetIngredientById)
	router.POST(baseURL+"/ingredients/:ingredient_id/associate_food", wrapper.AssociateFoodWithIngredient)
	router.POST(baseURL+"/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST(baseURL+"/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET(baseURL+"/meals", wrapper.ListMeals)
	router.GET(baseURL+"/meals/:meal_id", wrapper.GetMealById)
	router.PATCH(baseURL+"/meals/:meal_id/recipes", wrapper.UpdateRecipesForMeal)
	router.POST(baseURL+"/meta/load_ingredient_mappings", wrapper.LoadIngredientMappings)
	router.GET(baseURL+"/photos", wrapper.ListPhotos)
	router.GET(baseURL+"/recipes", wrapper.ListRecipes)
	router.POST(baseURL+"/recipes", wrapper.CreateRecipes)
	router.GET(baseURL+"/recipes/bulk", wrapper.GetRecipesByIds)
	router.POST(baseURL+"/recipes/scrape", wrapper.ScrapeRecipe)
	router.POST(baseURL+"/recipes/sum", wrapper.SumRecipes)
	router.GET(baseURL+"/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET(baseURL+"/recipes/:recipe_id/latex", wrapper.GetLatexByRecipeId)
	router.GET(baseURL+"/search", wrapper.Search)
	router.GET(baseURL+"/sync", wrapper.DoSync)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"2bqZOLXvn7//TwAAAP//btgdnbuzAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
