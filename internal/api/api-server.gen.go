// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// Get app config
	// (GET /config)
	GetConfig(ctx echo.Context) error
	// Get foods
	// (GET /data/recipe_dependencies)
	RecipeDependencies(ctx echo.Context) error
	// Get foods
	// (GET /foods/bulk)
	GetFoodsByIds(ctx echo.Context, params GetFoodsByIdsParams) error
	// Search foods
	// (GET /foods/search)
	SearchFoods(ctx echo.Context, params SearchFoodsParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Get a specific ingredient
	// (GET /ingredients/{ingredient_id})
	GetIngredientById(ctx echo.Context, ingredientId string) error
	// Assosiates a food with a given ingredient
	// (POST /ingredients/{ingredient_id}/associate_food)
	AssociateFoodWithIngredient(ctx echo.Context, ingredientId string, params AssociateFoodWithIngredientParams) error
	// Converts an ingredient to a recipe, updating all recipes depending on it
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// Info for a specific meal
	// (GET /meals/{meal_id})
	GetMealById(ctx echo.Context, mealId string) error
	// Update the recipes associated with a given meal
	// (PATCH /meals/{meal_id}/recipes)
	UpdateRecipesForMeal(ctx echo.Context, mealId string) error
	// load mappings
	// (POST /meta/load_ingredient_mappings)
	LoadIngredientMappings(ctx echo.Context) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Get recipes
	// (GET /recipes/bulk)
	GetRecipesByIds(ctx echo.Context, params GetRecipesByIdsParams) error
	// scrape a recipe by URL
	// (POST /recipes/scrape)
	ScrapeRecipe(ctx echo.Context) error
	// sum up recipes
	// (POST /recipes/sum)
	SumRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// recipe as latex
	// (GET /recipes/{recipe_id}/latex)
	GetLatexByRecipeId(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
	// perform sync
	// (GET /sync)
	DoSync(ctx echo.Context, params DoSyncParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// GetConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfig(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetConfig(ctx)
	return err
}

// RecipeDependencies converts echo context to params.
func (w *ServerInterfaceWrapper) RecipeDependencies(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RecipeDependencies(ctx)
	return err
}

// GetFoodsByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodsByIds(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFoodsByIdsParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", false, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodsByIds(ctx, params)
	return err
}

// SearchFoods converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFoods(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFoodsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFoods(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "fdc_id", runtime.ParamLocationPath, ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "ingredient_id" -------------

	err = runtime.BindQueryParameter("form", false, false, "ingredient_id", ctx.QueryParams(), &params.IngredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// GetIngredientById converts echo context to params.
func (w *ServerInterfaceWrapper) GetIngredientById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIngredientById(ctx, ingredientId)
	return err
}

// AssociateFoodWithIngredient converts echo context to params.
func (w *ServerInterfaceWrapper) AssociateFoodWithIngredient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssociateFoodWithIngredientParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssociateFoodWithIngredient(ctx, ingredientId, params)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// GetMealById converts echo context to params.
func (w *ServerInterfaceWrapper) GetMealById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMealById(ctx, mealId)
	return err
}

// UpdateRecipesForMeal converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRecipesForMeal(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRecipesForMeal(ctx, mealId)
	return err
}

// LoadIngredientMappings converts echo context to params.
func (w *ServerInterfaceWrapper) LoadIngredientMappings(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LoadIngredientMappings(ctx)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipesByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipesByIds(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecipesByIdsParams
	// ------------- Required query parameter "recipe_id" -------------

	err = runtime.BindQueryParameter("form", false, true, "recipe_id", ctx.QueryParams(), &params.RecipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipesByIds(ctx, params)
	return err
}

// ScrapeRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ScrapeRecipe(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ScrapeRecipe(ctx)
	return err
}

// SumRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) SumRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SumRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// GetLatexByRecipeId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatexByRecipeId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLatexByRecipeId(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// DoSync converts echo context to params.
func (w *ServerInterfaceWrapper) DoSync(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params DoSyncParams
	// ------------- Required query parameter "lookback_days" -------------

	err = runtime.BindQueryParameter("form", true, true, "lookback_days", ctx.QueryParams(), &params.LookbackDays)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter lookback_days: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DoSync(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/albums", wrapper.ListAllAlbums)
	router.POST(baseURL+"/auth", wrapper.AuthLogin)
	router.GET(baseURL+"/config", wrapper.GetConfig)
	router.GET(baseURL+"/data/recipe_dependencies", wrapper.RecipeDependencies)
	router.GET(baseURL+"/foods/bulk", wrapper.GetFoodsByIds)
	router.GET(baseURL+"/foods/search", wrapper.SearchFoods)
	router.GET(baseURL+"/foods/:fdc_id", wrapper.GetFoodById)
	router.GET(baseURL+"/ingredients", wrapper.ListIngredients)
	router.POST(baseURL+"/ingredients", wrapper.CreateIngredients)
	router.GET(baseURL+"/ingredients/:ingredient_id", wrapper.GetIngredientById)
	router.POST(baseURL+"/ingredients/:ingredient_id/associate_food", wrapper.AssociateFoodWithIngredient)
	router.POST(baseURL+"/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST(baseURL+"/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET(baseURL+"/meals", wrapper.ListMeals)
	router.GET(baseURL+"/meals/:meal_id", wrapper.GetMealById)
	router.PATCH(baseURL+"/meals/:meal_id/recipes", wrapper.UpdateRecipesForMeal)
	router.POST(baseURL+"/meta/load_ingredient_mappings", wrapper.LoadIngredientMappings)
	router.GET(baseURL+"/photos", wrapper.ListPhotos)
	router.GET(baseURL+"/recipes", wrapper.ListRecipes)
	router.POST(baseURL+"/recipes", wrapper.CreateRecipes)
	router.GET(baseURL+"/recipes/bulk", wrapper.GetRecipesByIds)
	router.POST(baseURL+"/recipes/scrape", wrapper.ScrapeRecipe)
	router.POST(baseURL+"/recipes/sum", wrapper.SumRecipes)
	router.GET(baseURL+"/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET(baseURL+"/recipes/:recipe_id/latex", wrapper.GetLatexByRecipeId)
	router.GET(baseURL+"/search", wrapper.Search)
	router.GET(baseURL+"/sync", wrapper.DoSync)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
