// Package api provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// Get foods
	// (GET /data/recipe_dependencies)
	RecipeDependencies(ctx echo.Context) error
	// Get foods
	// (GET /foods/bulk)
	GetFoodsByIds(ctx echo.Context, params GetFoodsByIdsParams) error
	// Search foods
	// (GET /foods/search)
	SearchFoods(ctx echo.Context, params SearchFoodsParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Get a specific ingredient
	// (GET /ingredients/{ingredient_id})
	GetIngredientById(ctx echo.Context, ingredientId string) error
	// Assosiates a food with a given ingredient
	// (POST /ingredients/{ingredient_id}/associate_food)
	AssociateFoodWithIngredient(ctx echo.Context, ingredientId string, params AssociateFoodWithIngredientParams) error
	// Converts an ingredient to a recipe, updating all recipes depending on it.
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// Info for a specific meal
	// (GET /meals/{meal_id})
	GetMealById(ctx echo.Context, mealId string) error
	// Update the recipes associated with a given meal
	// (PATCH /meals/{meal_id}/recipes)
	UpdateRecipesForMeal(ctx echo.Context, mealId string) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Get recipes
	// (GET /recipes/bulk)
	GetRecipesByIds(ctx echo.Context, params GetRecipesByIdsParams) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// RecipeDependencies converts echo context to params.
func (w *ServerInterfaceWrapper) RecipeDependencies(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RecipeDependencies(ctx)
	return err
}

// GetFoodsByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodsByIds(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFoodsByIdsParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodsByIds(ctx, params)
	return err
}

// SearchFoods converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFoods(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFoodsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "data_types" -------------

	err = runtime.BindQueryParameter("form", true, false, "data_types", ctx.QueryParams(), &params.DataTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter data_types: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFoods(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameter("simple", false, "fdc_id", ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "ingredient_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "ingredient_id", ctx.QueryParams(), &params.IngredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// GetIngredientById converts echo context to params.
func (w *ServerInterfaceWrapper) GetIngredientById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIngredientById(ctx, ingredientId)
	return err
}

// AssociateFoodWithIngredient converts echo context to params.
func (w *ServerInterfaceWrapper) AssociateFoodWithIngredient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssociateFoodWithIngredientParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssociateFoodWithIngredient(ctx, ingredientId, params)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameter("simple", false, "ingredient_id", ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// GetMealById converts echo context to params.
func (w *ServerInterfaceWrapper) GetMealById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameter("simple", false, "meal_id", ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMealById(ctx, mealId)
	return err
}

// UpdateRecipesForMeal converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRecipesForMeal(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameter("simple", false, "meal_id", ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRecipesForMeal(ctx, mealId)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipesByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipesByIds(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecipesByIdsParams
	// ------------- Required query parameter "recipe_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "recipe_id", ctx.QueryParams(), &params.RecipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipesByIds(ctx, params)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameter("simple", false, "recipe_id", ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set("bearerAuth.Scopes", []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/albums", wrapper.ListAllAlbums)
	router.POST("/auth", wrapper.AuthLogin)
	router.GET("/data/recipe_dependencies", wrapper.RecipeDependencies)
	router.GET("/foods/bulk", wrapper.GetFoodsByIds)
	router.GET("/foods/search", wrapper.SearchFoods)
	router.GET("/foods/:fdc_id", wrapper.GetFoodById)
	router.GET("/ingredients", wrapper.ListIngredients)
	router.POST("/ingredients", wrapper.CreateIngredients)
	router.GET("/ingredients/:ingredient_id", wrapper.GetIngredientById)
	router.POST("/ingredients/:ingredient_id/associate_food", wrapper.AssociateFoodWithIngredient)
	router.POST("/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST("/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET("/meals", wrapper.ListMeals)
	router.GET("/meals/:meal_id", wrapper.GetMealById)
	router.PATCH("/meals/:meal_id/recipes", wrapper.UpdateRecipesForMeal)
	router.GET("/photos", wrapper.ListPhotos)
	router.GET("/recipes", wrapper.ListRecipes)
	router.POST("/recipes", wrapper.CreateRecipes)
	router.GET("/recipes/bulk", wrapper.GetRecipesByIds)
	router.GET("/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET("/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"ZgAA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
