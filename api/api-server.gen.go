// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// Get foods
	// (GET /data/recipe_dependencies)
	RecipeDependencies(ctx echo.Context) error
	// Get foods
	// (GET /foods/bulk)
	GetFoodsByIds(ctx echo.Context, params GetFoodsByIdsParams) error
	// Search foods
	// (GET /foods/search)
	SearchFoods(ctx echo.Context, params SearchFoodsParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Get a specific ingredient
	// (GET /ingredients/{ingredient_id})
	GetIngredientById(ctx echo.Context, ingredientId string) error
	// Assosiates a food with a given ingredient
	// (POST /ingredients/{ingredient_id}/associate_food)
	AssociateFoodWithIngredient(ctx echo.Context, ingredientId string, params AssociateFoodWithIngredientParams) error
	// Converts an ingredient to a recipe, updating all recipes depending on it
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// Info for a specific meal
	// (GET /meals/{meal_id})
	GetMealById(ctx echo.Context, mealId string) error
	// Update the recipes associated with a given meal
	// (PATCH /meals/{meal_id}/recipes)
	UpdateRecipesForMeal(ctx echo.Context, mealId string) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Get recipes
	// (GET /recipes/bulk)
	GetRecipesByIds(ctx echo.Context, params GetRecipesByIdsParams) error
	// scrape a recipe by URL
	// (POST /recipes/scrape)
	ScrapeRecipe(ctx echo.Context) error
	// sum up recipes
	// (POST /recipes/sum)
	SumRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// recipe as latex
	// (GET /recipes/{recipe_id}/latex)
	GetLatexByRecipeId(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// RecipeDependencies converts echo context to params.
func (w *ServerInterfaceWrapper) RecipeDependencies(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RecipeDependencies(ctx)
	return err
}

// GetFoodsByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodsByIds(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFoodsByIdsParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodsByIds(ctx, params)
	return err
}

// SearchFoods converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFoods(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFoodsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "data_types" -------------

	err = runtime.BindQueryParameter("form", true, false, "data_types", ctx.QueryParams(), &params.DataTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter data_types: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFoods(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "fdc_id", runtime.ParamLocationPath, ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "ingredient_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "ingredient_id", ctx.QueryParams(), &params.IngredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// GetIngredientById converts echo context to params.
func (w *ServerInterfaceWrapper) GetIngredientById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIngredientById(ctx, ingredientId)
	return err
}

// AssociateFoodWithIngredient converts echo context to params.
func (w *ServerInterfaceWrapper) AssociateFoodWithIngredient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssociateFoodWithIngredientParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssociateFoodWithIngredient(ctx, ingredientId, params)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// GetMealById converts echo context to params.
func (w *ServerInterfaceWrapper) GetMealById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMealById(ctx, mealId)
	return err
}

// UpdateRecipesForMeal converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRecipesForMeal(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRecipesForMeal(ctx, mealId)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipesByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipesByIds(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecipesByIdsParams
	// ------------- Required query parameter "recipe_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "recipe_id", ctx.QueryParams(), &params.RecipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipesByIds(ctx, params)
	return err
}

// ScrapeRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ScrapeRecipe(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ScrapeRecipe(ctx)
	return err
}

// SumRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) SumRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SumRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// GetLatexByRecipeId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatexByRecipeId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLatexByRecipeId(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/albums", wrapper.ListAllAlbums)
	router.POST(baseURL+"/auth", wrapper.AuthLogin)
	router.GET(baseURL+"/data/recipe_dependencies", wrapper.RecipeDependencies)
	router.GET(baseURL+"/foods/bulk", wrapper.GetFoodsByIds)
	router.GET(baseURL+"/foods/search", wrapper.SearchFoods)
	router.GET(baseURL+"/foods/:fdc_id", wrapper.GetFoodById)
	router.GET(baseURL+"/ingredients", wrapper.ListIngredients)
	router.POST(baseURL+"/ingredients", wrapper.CreateIngredients)
	router.GET(baseURL+"/ingredients/:ingredient_id", wrapper.GetIngredientById)
	router.POST(baseURL+"/ingredients/:ingredient_id/associate_food", wrapper.AssociateFoodWithIngredient)
	router.POST(baseURL+"/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST(baseURL+"/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET(baseURL+"/meals", wrapper.ListMeals)
	router.GET(baseURL+"/meals/:meal_id", wrapper.GetMealById)
	router.PATCH(baseURL+"/meals/:meal_id/recipes", wrapper.UpdateRecipesForMeal)
	router.GET(baseURL+"/photos", wrapper.ListPhotos)
	router.GET(baseURL+"/recipes", wrapper.ListRecipes)
	router.POST(baseURL+"/recipes", wrapper.CreateRecipes)
	router.GET(baseURL+"/recipes/bulk", wrapper.GetRecipesByIds)
	router.POST(baseURL+"/recipes/scrape", wrapper.ScrapeRecipe)
	router.POST(baseURL+"/recipes/sum", wrapper.SumRecipes)
	router.GET(baseURL+"/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET(baseURL+"/recipes/:recipe_id/latex", wrapper.GetLatexByRecipeId)
	router.GET(baseURL+"/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"CgAA//9ZOYL+3noAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
