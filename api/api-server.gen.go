// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.9.0 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List all albums
	// (GET /albums)
	ListAllAlbums(ctx echo.Context) error
	// Google Login callback
	// (POST /auth)
	AuthLogin(ctx echo.Context, params AuthLoginParams) error
	// Get app config
	// (GET /config)
	GetConfig(ctx echo.Context) error
	// Get foods
	// (GET /data/recipe_dependencies)
	RecipeDependencies(ctx echo.Context) error
	// Get foods
	// (GET /foods/bulk)
	GetFoodsByIds(ctx echo.Context, params GetFoodsByIdsParams) error
	// Search foods
	// (GET /foods/search)
	SearchFoods(ctx echo.Context, params SearchFoodsParams) error
	// get a FDC entry by id
	// (GET /foods/{fdc_id})
	GetFoodById(ctx echo.Context, fdcId int) error
	// List all ingredients
	// (GET /ingredients)
	ListIngredients(ctx echo.Context, params ListIngredientsParams) error
	// Create a ingredient
	// (POST /ingredients)
	CreateIngredients(ctx echo.Context) error
	// Get a specific ingredient
	// (GET /ingredients/{ingredient_id})
	GetIngredientById(ctx echo.Context, ingredientId string) error
	// Assosiates a food with a given ingredient
	// (POST /ingredients/{ingredient_id}/associate_food)
	AssociateFoodWithIngredient(ctx echo.Context, ingredientId string, params AssociateFoodWithIngredientParams) error
	// Converts an ingredient to a recipe, updating all recipes depending on it
	// (POST /ingredients/{ingredient_id}/convert_to_recipe)
	ConvertIngredientToRecipe(ctx echo.Context, ingredientId string) error
	// Merges the provide ingredients in the body into the param
	// (POST /ingredients/{ingredient_id}/merge)
	MergeIngredients(ctx echo.Context, ingredientId string) error
	// List all meals
	// (GET /meals)
	ListMeals(ctx echo.Context, params ListMealsParams) error
	// Info for a specific meal
	// (GET /meals/{meal_id})
	GetMealById(ctx echo.Context, mealId string) error
	// Update the recipes associated with a given meal
	// (PATCH /meals/{meal_id}/recipes)
	UpdateRecipesForMeal(ctx echo.Context, mealId string) error
	// load mappings
	// (POST /meta/load_ingredient_mappings)
	LoadIngredientMappings(ctx echo.Context) error
	// List all photos
	// (GET /photos)
	ListPhotos(ctx echo.Context, params ListPhotosParams) error
	// List all recipes
	// (GET /recipes)
	ListRecipes(ctx echo.Context, params ListRecipesParams) error
	// Create a recipe
	// (POST /recipes)
	CreateRecipes(ctx echo.Context) error
	// Get recipes
	// (GET /recipes/bulk)
	GetRecipesByIds(ctx echo.Context, params GetRecipesByIdsParams) error
	// scrape a recipe by URL
	// (POST /recipes/scrape)
	ScrapeRecipe(ctx echo.Context) error
	// sum up recipes
	// (POST /recipes/sum)
	SumRecipes(ctx echo.Context) error
	// Info for a specific recipe
	// (GET /recipes/{recipe_id})
	GetRecipeById(ctx echo.Context, recipeId string) error
	// recipe as latex
	// (GET /recipes/{recipe_id}/latex)
	GetLatexByRecipeId(ctx echo.Context, recipeId string) error
	// Search recipes and ingredients
	// (GET /search)
	Search(ctx echo.Context, params SearchParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAllAlbums converts echo context to params.
func (w *ServerInterfaceWrapper) ListAllAlbums(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListAllAlbums(ctx)
	return err
}

// AuthLogin converts echo context to params.
func (w *ServerInterfaceWrapper) AuthLogin(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params AuthLoginParams
	// ------------- Required query parameter "code" -------------

	err = runtime.BindQueryParameter("form", true, true, "code", ctx.QueryParams(), &params.Code)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter code: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AuthLogin(ctx, params)
	return err
}

// GetConfig converts echo context to params.
func (w *ServerInterfaceWrapper) GetConfig(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetConfig(ctx)
	return err
}

// RecipeDependencies converts echo context to params.
func (w *ServerInterfaceWrapper) RecipeDependencies(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RecipeDependencies(ctx)
	return err
}

// GetFoodsByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodsByIds(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFoodsByIdsParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodsByIds(ctx, params)
	return err
}

// SearchFoods converts echo context to params.
func (w *ServerInterfaceWrapper) SearchFoods(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchFoodsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "data_types" -------------

	err = runtime.BindQueryParameter("form", true, false, "data_types", ctx.QueryParams(), &params.DataTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter data_types: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchFoods(ctx, params)
	return err
}

// GetFoodById converts echo context to params.
func (w *ServerInterfaceWrapper) GetFoodById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "fdc_id" -------------
	var fdcId int

	err = runtime.BindStyledParameterWithLocation("simple", false, "fdc_id", runtime.ParamLocationPath, ctx.Param("fdc_id"), &fdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFoodById(ctx, fdcId)
	return err
}

// ListIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) ListIngredients(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListIngredientsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "ingredient_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "ingredient_id", ctx.QueryParams(), &params.IngredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListIngredients(ctx, params)
	return err
}

// CreateIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) CreateIngredients(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateIngredients(ctx)
	return err
}

// GetIngredientById converts echo context to params.
func (w *ServerInterfaceWrapper) GetIngredientById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetIngredientById(ctx, ingredientId)
	return err
}

// AssociateFoodWithIngredient converts echo context to params.
func (w *ServerInterfaceWrapper) AssociateFoodWithIngredient(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AssociateFoodWithIngredientParams
	// ------------- Required query parameter "fdc_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "fdc_id", ctx.QueryParams(), &params.FdcId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fdc_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssociateFoodWithIngredient(ctx, ingredientId, params)
	return err
}

// ConvertIngredientToRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ConvertIngredientToRecipe(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ConvertIngredientToRecipe(ctx, ingredientId)
	return err
}

// MergeIngredients converts echo context to params.
func (w *ServerInterfaceWrapper) MergeIngredients(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "ingredient_id" -------------
	var ingredientId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "ingredient_id", runtime.ParamLocationPath, ctx.Param("ingredient_id"), &ingredientId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredient_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.MergeIngredients(ctx, ingredientId)
	return err
}

// ListMeals converts echo context to params.
func (w *ServerInterfaceWrapper) ListMeals(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMealsParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListMeals(ctx, params)
	return err
}

// GetMealById converts echo context to params.
func (w *ServerInterfaceWrapper) GetMealById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetMealById(ctx, mealId)
	return err
}

// UpdateRecipesForMeal converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRecipesForMeal(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "meal_id" -------------
	var mealId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "meal_id", runtime.ParamLocationPath, ctx.Param("meal_id"), &mealId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter meal_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRecipesForMeal(ctx, mealId)
	return err
}

// LoadIngredientMappings converts echo context to params.
func (w *ServerInterfaceWrapper) LoadIngredientMappings(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LoadIngredientMappings(ctx)
	return err
}

// ListPhotos converts echo context to params.
func (w *ServerInterfaceWrapper) ListPhotos(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPhotosParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListPhotos(ctx, params)
	return err
}

// ListRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) ListRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRecipesParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ListRecipes(ctx, params)
	return err
}

// CreateRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateRecipes(ctx)
	return err
}

// GetRecipesByIds converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipesByIds(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRecipesByIdsParams
	// ------------- Required query parameter "recipe_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "recipe_id", ctx.QueryParams(), &params.RecipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipesByIds(ctx, params)
	return err
}

// ScrapeRecipe converts echo context to params.
func (w *ServerInterfaceWrapper) ScrapeRecipe(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ScrapeRecipe(ctx)
	return err
}

// SumRecipes converts echo context to params.
func (w *ServerInterfaceWrapper) SumRecipes(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SumRecipes(ctx)
	return err
}

// GetRecipeById converts echo context to params.
func (w *ServerInterfaceWrapper) GetRecipeById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetRecipeById(ctx, recipeId)
	return err
}

// GetLatexByRecipeId converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatexByRecipeId(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "recipe_id" -------------
	var recipeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "recipe_id", runtime.ParamLocationPath, ctx.Param("recipe_id"), &recipeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter recipe_id: %s", err))
	}

	ctx.Set(BearerAuthScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLatexByRecipeId(ctx, recipeId)
	return err
}

// Search converts echo context to params.
func (w *ServerInterfaceWrapper) Search(ctx echo.Context) error {
	var err error

	ctx.Set(BearerAuthScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams
	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", ctx.QueryParams(), &params.Offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.Search(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/albums", wrapper.ListAllAlbums)
	router.POST(baseURL+"/auth", wrapper.AuthLogin)
	router.GET(baseURL+"/config", wrapper.GetConfig)
	router.GET(baseURL+"/data/recipe_dependencies", wrapper.RecipeDependencies)
	router.GET(baseURL+"/foods/bulk", wrapper.GetFoodsByIds)
	router.GET(baseURL+"/foods/search", wrapper.SearchFoods)
	router.GET(baseURL+"/foods/:fdc_id", wrapper.GetFoodById)
	router.GET(baseURL+"/ingredients", wrapper.ListIngredients)
	router.POST(baseURL+"/ingredients", wrapper.CreateIngredients)
	router.GET(baseURL+"/ingredients/:ingredient_id", wrapper.GetIngredientById)
	router.POST(baseURL+"/ingredients/:ingredient_id/associate_food", wrapper.AssociateFoodWithIngredient)
	router.POST(baseURL+"/ingredients/:ingredient_id/convert_to_recipe", wrapper.ConvertIngredientToRecipe)
	router.POST(baseURL+"/ingredients/:ingredient_id/merge", wrapper.MergeIngredients)
	router.GET(baseURL+"/meals", wrapper.ListMeals)
	router.GET(baseURL+"/meals/:meal_id", wrapper.GetMealById)
	router.PATCH(baseURL+"/meals/:meal_id/recipes", wrapper.UpdateRecipesForMeal)
	router.POST(baseURL+"/meta/load_ingredient_mappings", wrapper.LoadIngredientMappings)
	router.GET(baseURL+"/photos", wrapper.ListPhotos)
	router.GET(baseURL+"/recipes", wrapper.ListRecipes)
	router.POST(baseURL+"/recipes", wrapper.CreateRecipes)
	router.GET(baseURL+"/recipes/bulk", wrapper.GetRecipesByIds)
	router.POST(baseURL+"/recipes/scrape", wrapper.ScrapeRecipe)
	router.POST(baseURL+"/recipes/sum", wrapper.SumRecipes)
	router.GET(baseURL+"/recipes/:recipe_id", wrapper.GetRecipeById)
	router.GET(baseURL+"/recipes/:recipe_id/latex", wrapper.GetLatexByRecipeId)
	router.GET(baseURL+"/search", wrapper.Search)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"SClomI2Nerh5+P8AAAD//6J01pgVgwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
